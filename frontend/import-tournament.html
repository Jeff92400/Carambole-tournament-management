<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Import Tournoi - Billard Ranking</title>
  <link rel="icon" type="image/png" href="images/FrenchBillard-Icon-small.png">
  <link rel="stylesheet" href="css/styles.css">
  <script src="js/branding.js"></script>
</head>
<body>
  <div class="container">
    <div class="navbar">
      <h2><img id="app-header-icon" src="images/FrenchBillard-Icon-small.png" alt="" style="height: 48px; width: 48px; vertical-align: middle; margin-right: 8px;" onerror="this.src='images/FrenchBillard-Icon-small.png';"><span id="app-org-name" data-page-title="Import Comp√©tition">CDB</span></h2>
      <div class="nav-links">
        <a href="dashboard.html">Accueil</a>
        <a href="rankings.html" class="nav-tooltip" data-tooltip="Classement par cat√©gorie de jeu au fur et √† mesure des tournois">Classements</a>
        <a href="generate-poules.html" class="nav-tooltip" data-tooltip="Comp√©titions √† jouer / Convocations">Comp√©titions</a>
        <a href="calendar.html" class="nav-tooltip" data-tooltip="Calendrier de la saison">Calendrier</a>
        <a href="emailing.html" class="nav-tooltip" data-tooltip="Annonces, relances, r√©sultats, convocation">Com joueurs</a>
        <a href="settings.html" class="admin-only nav-tooltip" data-tooltip="R√©serv√© aux administrateurs">Param√®tres</a>
        <a href="#" id="logoutBtn" class="nav-logout">D√©connexion</a>
      </div>
    </div>

    <div id="errorMessage" class="error" style="display: none;"></div>
    <div id="successMessage" class="success" style="display: none;"></div>

    <div class="card">
      <h3 id="importCardTitle">Enregistrer les resultats d'une competition</h3>
      <p id="importCardDescription" style="color: #666; margin-bottom: 20px;">
        Selectionnez la categorie, le numero du tournoi et la saison, puis importez le fichier CSV des resultats.
      </p>

      <form id="importForm">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
          <div class="form-group">
            <label for="modeSelect">Mode de jeu *</label>
            <select id="modeSelect" required>
              <option value="">-- S√©lectionner --</option>
            </select>
          </div>
          <div class="form-group">
            <label for="levelSelect">Classement FFB *</label>
            <select id="levelSelect" required>
              <option value="">-- S√©lectionner --</option>
            </select>
            <!-- Hidden select to store the resolved category ID -->
            <select id="categorySelect" style="display: none;">
              <option value="">-- S√©lectionner une cat√©gorie --</option>
            </select>
          </div>
        </div>

        <div class="form-group">
          <label for="tournamentNumber">Num√©ro du tournoi *</label>
          <select id="tournamentNumber" required>
            <option value="">-- S√©lectionner --</option>
            <option value="1">Tournoi 1</option>
            <option value="2">Tournoi 2</option>
            <option value="3">Tournoi 3</option>
            <option value="4">Finale D√©partementale</option>
          </select>
        </div>

        <div class="form-group">
          <label for="tournamentDate">Date du tournoi *</label>
          <input type="date" id="tournamentDate" required>
        </div>

        <div class="form-group">
          <label for="season">Saison (calcul√©e automatiquement)</label>
          <input type="text" id="season" placeholder="Ex: 2024-2025" readonly style="background: #f0f0f0;">
        </div>

        <!-- Single file upload zone (standard mode) -->
        <div class="file-upload" id="fileUpload">
          <p>üìÅ Cliquez pour s√©lectionner un fichier CSV</p>
          <p style="font-size: 12px; color: #999; margin-top: 10px;">ou glissez-d√©posez le fichier ici</p>
          <input type="file" id="fileInput" accept=".csv" required>
          <div id="fileName" class="file-name" style="display: none;"></div>
        </div>

        <!-- Multi-file upload zone (journees mode, hidden by default) -->
        <div id="journeesUpload" style="display: none;">
          <!-- Player count input -->
          <div style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 500;">Nombre de joueurs inscrits :</label>
            <div style="display: flex; gap: 10px; align-items: center;">
              <input type="number" id="playerCountInput" min="2" max="50" placeholder="ex: 12" style="width: 120px; padding: 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;" oninput="updatePhaseBlocs()">
              <span id="phaseHint" style="color: #666; font-size: 13px;"></span>
            </div>
          </div>

          <!-- Phase drop zones (generated dynamically) -->
          <div id="phaseBlocsContainer" style="display: none;">
            <h4 style="margin-bottom: 12px; color: var(--color-primary, #1F4788);">Fichiers CSV par phase :</h4>
            <div id="phaseBlocs"></div>
          </div>

          <!-- Hidden inputs for backward compat -->
          <input type="file" id="multiFileInput" accept=".csv" multiple style="display: none;">
          <div id="phaseChecklist" style="display: none;"><div id="phaseList"></div></div>
        </div>

        <button type="submit" class="btn" id="importBtn">Enregistrer la competition</button>
      </form>
    </div>

    <div class="card" id="resultsCard" style="display: none;">
      <h3>R√©sultats de l'import</h3>
      <div id="importResults"></div>
    </div>

    <!-- Mixed-category bonus card (journees mode only) -->
    <div class="card" id="categoryBonusCard" style="display: none;">
      <h3>Bonus categories mixtes</h3>
      <div style="margin-bottom: 15px; padding: 12px; background: #e7f3ff; border-left: 4px solid var(--color-primary, #1F4788); border-radius: 4px;">
        <strong>Information :</strong> Ajoutez +1 point par match joue contre un adversaire d'une categorie superieure.
      </div>
      <div style="overflow-x: auto;">
        <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
          <thead>
            <tr style="background: var(--color-primary, #1F4788); color: white;">
              <th style="padding: 10px; text-align: left;">Joueur</th>
              <th style="padding: 10px; text-align: center;">Licence</th>
              <th style="padding: 10px; text-align: center;">Classement FFB</th>
              <th style="padding: 10px; text-align: center;">Position</th>
              <th style="padding: 10px; text-align: center;">Bonus (+1/match)</th>
            </tr>
          </thead>
          <tbody id="categoryBonusBody">
          </tbody>
        </table>
      </div>
      <div style="display: flex; gap: 10px; margin-top: 20px;">
        <button id="saveBonusBtn" class="btn" style="flex: 1; background: #28a745;">Enregistrer les bonus</button>
        <button id="skipBonusBtn" class="btn" style="flex: 1; background: #6c757d;">Passer</button>
      </div>
      <div id="bonusMessage" style="display: none; margin-top: 15px; padding: 10px; border-radius: 4px;"></div>
    </div>

    <!-- Modal for unknown players -->
    <div id="unknownPlayersModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
      <div style="background: white; padding: 30px; border-radius: 12px; max-width: 600px; max-height: 80vh; overflow-y: auto; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
        <h3 style="margin-top: 0;">‚ö†Ô∏è Joueurs inconnus d√©tect√©s</h3>
        <p style="color: #666; margin-bottom: 20px;">Les joueurs suivants n'existent pas dans la base de donn√©es. Veuillez s√©lectionner leur club pour les cr√©er.</p>
        <div id="unknownPlayersList"></div>
        <div style="display: flex; gap: 10px; margin-top: 20px;">
          <button id="createPlayersBtn" class="btn" style="flex: 1;">Cr√©er les joueurs et continuer</button>
          <button id="cancelBtn" class="btn" style="flex: 1; background: #999;">Annuler</button>
        </div>
      </div>
    </div>

    <!-- Modal for existing tournament warning -->
    <div id="existingTournamentModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
      <div style="background: white; padding: 30px; border-radius: 12px; max-width: 500px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
        <h3 style="margin-top: 0; color: #dc3545;">‚ö†Ô∏è Tournoi existant</h3>
        <p style="color: #666; margin-bottom: 15px;">Un tournoi existe d√©j√† pour cette cat√©gorie/num√©ro/saison :</p>
        <div id="existingTournamentInfo" style="background: #fff3cd; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ffc107;">
        </div>
        <p style="color: #dc3545; font-weight: bold; margin-bottom: 20px;">
          En continuant, les r√©sultats existants seront d√©finitivement remplac√©s !
        </p>
        <div style="display: flex; gap: 10px;">
          <button id="confirmOverwriteBtn" class="btn" style="flex: 1; background: #dc3545;">Remplacer le tournoi</button>
          <button id="cancelOverwriteBtn" class="btn" style="flex: 1; background: #6c757d;">Annuler</button>
        </div>
      </div>
    </div>

    <!-- Modal for sending results email -->
    <div id="sendResultsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
      <div style="background: white; padding: 30px; border-radius: 12px; max-width: 450px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); text-align: center;">
        <div style="font-size: 48px; margin-bottom: 15px;">üìß</div>
        <h3 style="margin-top: 0; color: #1F4788;">Envoyer les r√©sultats ?</h3>
        <p style="color: #666; margin-bottom: 25px;">
          Voulez-vous envoyer les r√©sultats du tournoi par email aux participants ?
        </p>
        <div style="display: flex; gap: 10px;">
          <button id="sendResultsYesBtn" class="btn" style="flex: 1; background: #28a745;">Oui, envoyer</button>
          <button id="sendResultsNoBtn" class="btn" style="flex: 1; background: #6c757d;">Plus tard</button>
        </div>
        <p style="font-size: 12px; color: #999; margin-top: 15px;">
          Vous pourrez envoyer les r√©sultats plus tard depuis la page Comp√©titions Jou√©es
        </p>
      </div>
    </div>
  </div>

  <script src="js/auth-utils.js"></script>
  <script src="js/app-branding.js"></script>
  <script>
    const API_URL = '/api';

    // Check authentication
    if (!requireAuth()) {
      throw new Error('Not authenticated'); // Stop script execution
    }
    const token = localStorage.getItem('token');

    // Check user role - this page is admin only
    const userRole = localStorage.getItem('userRole');
    if (userRole !== 'admin') {
      alert('Acc√®s r√©serv√© aux administrateurs');
      window.location.href = 'dashboard.html';
    }


    // Calculate season from tournament date
    // September to July determines the season
    // Example: Oct 2025 ‚Üí 2025-2026, July 2026 ‚Üí 2025-2026, Sept 2026 ‚Üí 2026-2027
    function calculateSeason(dateString) {
      const date = new Date(dateString);
      const month = date.getMonth() + 1; // 1-12
      const year = date.getFullYear();

      // If month is September (9) or later, season starts this year
      // If month is before September, season started last year
      const startYear = month >= 9 ? year : year - 1;
      const endYear = startYear + 1;

      return `${startYear}-${endYear}`;
    }

    // Update season when tournament date changes
    document.getElementById('tournamentDate').addEventListener('change', (e) => {
      const date = e.target.value;
      if (date) {
        const season = calculateSeason(date);
        document.getElementById('season').value = season;
      }
    });

    // Load categories
    async function loadCategories() {
      try {
        const response = await fetch(`${API_URL}/tournaments/categories`, {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        if (response.ok) {
          categories = await response.json();

          // Populate mode selector with unique game types
          const modes = [...new Set(categories.map(c => c.game_type))].sort();
          const modeSelect = document.getElementById('modeSelect');
          modeSelect.innerHTML = '<option value="">-- S√©lectionner --</option>';
          modes.forEach(mode => {
            modeSelect.innerHTML += `<option value="${mode}">${mode}</option>`;
          });

          // Keep hidden categorySelect for compatibility
          const select = document.getElementById('categorySelect');
          select.innerHTML = '<option value="">-- S√©lectionner une cat√©gorie --</option>';
          categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.id;
            option.textContent = category.display_name;
            select.appendChild(option);
          });
        }
      } catch (error) {
        console.error('Error loading categories:', error);
      }
    }

    // Mode selector change - populate levels
    document.getElementById('modeSelect').addEventListener('change', (e) => {
      const selectedMode = e.target.value;
      const levelSelect = document.getElementById('levelSelect');
      const categorySelect = document.getElementById('categorySelect');

      levelSelect.innerHTML = '<option value="">-- S√©lectionner --</option>';
      categorySelect.value = '';

      if (selectedMode) {
        // Filter categories by selected mode and get unique levels
        const levels = categories
          .filter(c => c.game_type === selectedMode)
          .map(c => c.level)
          .filter((v, i, a) => a.indexOf(v) === i)
          .sort();

        levels.forEach(level => {
          levelSelect.innerHTML += `<option value="${level}">${level}</option>`;
        });
      }
    });

    // Level selector change - set category
    document.getElementById('levelSelect').addEventListener('change', (e) => {
      const selectedMode = document.getElementById('modeSelect').value;
      const selectedLevel = e.target.value;
      const categorySelect = document.getElementById('categorySelect');

      if (selectedMode && selectedLevel) {
        // Find the matching category
        const matchingCategory = categories.find(c =>
          c.game_type === selectedMode && c.level === selectedLevel
        );
        if (matchingCategory) {
          categorySelect.value = matchingCategory.id;
        }
      } else {
        categorySelect.value = '';
      }
    });

    // File upload handling
    const fileUpload = document.getElementById('fileUpload');
    const fileInput = document.getElementById('fileInput');
    const fileName = document.getElementById('fileName');

    fileUpload.addEventListener('click', () => {
      fileInput.click();
    });

    fileUpload.addEventListener('dragover', (e) => {
      e.preventDefault();
      fileUpload.style.background = '#f0f0f0';
    });

    fileUpload.addEventListener('dragleave', () => {
      fileUpload.style.background = '';
    });

    fileUpload.addEventListener('drop', (e) => {
      e.preventDefault();
      fileUpload.style.background = '';

      if (e.dataTransfer.files.length > 0) {
        fileInput.files = e.dataTransfer.files;
        fileName.textContent = e.dataTransfer.files[0].name;
        fileName.style.display = 'block';
      }
    });

    fileInput.addEventListener('change', () => {
      if (fileInput.files.length > 0) {
        fileName.textContent = fileInput.files[0].name;
        fileName.style.display = 'block';
      }
    });

    // Global variables for import
    let clubs = [];
    let categories = [];
    let unknownPlayers = [];
    let currentFormData = null;

    // Load clubs for dropdown
    async function loadClubs() {
      try {
        const response = await fetch(`${API_URL}/clubs`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
          clubs = await response.json();
        }
      } catch (error) {
        console.error('Error loading clubs:', error);
      }
    }

    // Show unknown players modal
    function showUnknownPlayersModal(players) {
      unknownPlayers = players;
      const modal = document.getElementById('unknownPlayersModal');
      const list = document.getElementById('unknownPlayersList');

      list.innerHTML = players.map((player, index) => `
        <div style="margin-bottom: 20px; padding: 15px; background: #f9f9f9; border-radius: 8px;">
          <div style="font-weight: bold; margin-bottom: 8px;">
            ${player.fullName} (${player.licence})
          </div>
          <label style="display: block; margin-bottom: 5px; font-size: 14px; color: #666;">Club *</label>
          <select id="club_${index}" required style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">-- S√©lectionner un club --</option>
            ${clubs.map(club => `<option value="${club.name}">${club.display_name}</option>`).join('')}
          </select>
        </div>
      `).join('');

      modal.style.display = 'flex';
    }

    // Hide modal
    function hideModal() {
      document.getElementById('unknownPlayersModal').style.display = 'none';
    }

    // Create players and continue import
    document.getElementById('createPlayersBtn').addEventListener('click', async () => {
      const playersToCreate = unknownPlayers.map((player, index) => {
        const clubSelect = document.getElementById(`club_${index}`);
        if (!clubSelect.value) {
          throw new Error(`Veuillez s√©lectionner un club pour ${player.fullName}`);
        }
        return {
          licence: player.licence,
          firstName: player.firstName,
          lastName: player.lastName,
          club: clubSelect.value
        };
      });

      try {
        // Create players
        const createResponse = await fetch(`${API_URL}/tournaments/create-players`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ players: playersToCreate })
        });

        if (!createResponse.ok) {
          throw new Error('Erreur lors de la cr√©ation des joueurs');
        }

        hideModal();

        // Now proceed with the actual import
        await performImport(currentFormData);

      } catch (error) {
        alert(error.message || 'Erreur lors de la cr√©ation des joueurs');
      }
    });

    // Cancel button
    document.getElementById('cancelBtn').addEventListener('click', () => {
      hideModal();
      document.getElementById('importBtn').disabled = false;
      document.getElementById('importBtn').textContent = 'Enregistrer la competition';
    });

    // Show existing tournament warning modal
    function showExistingTournamentModal(tournament) {
      const modal = document.getElementById('existingTournamentModal');
      const info = document.getElementById('existingTournamentInfo');

      const importDate = tournament.importDate
        ? new Date(tournament.importDate).toLocaleDateString('fr-FR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' })
        : 'Non renseign√©e';

      info.innerHTML = `
        <p style="margin: 0 0 8px 0;"><strong>${tournament.categoryName}</strong></p>
        <p style="margin: 0 0 8px 0;">Tournoi ${tournament.tournamentNumber} - Saison ${tournament.season}</p>
        <p style="margin: 0 0 8px 0;">Joueurs enregistr√©s : <strong>${tournament.playerCount}</strong></p>
        <p style="margin: 0; font-size: 12px; color: #666;">Import√© le : ${importDate}</p>
      `;

      modal.style.display = 'flex';
    }

    // Hide existing tournament modal
    function hideExistingTournamentModal() {
      document.getElementById('existingTournamentModal').style.display = 'none';
    }

    // Confirm overwrite button
    document.getElementById('confirmOverwriteBtn').addEventListener('click', async () => {
      hideExistingTournamentModal();
      await proceedWithValidation();
    });

    // Cancel overwrite button
    document.getElementById('cancelOverwriteBtn').addEventListener('click', () => {
      hideExistingTournamentModal();
      document.getElementById('importBtn').disabled = false;
      document.getElementById('importBtn').textContent = 'Enregistrer la competition';
    });

    // Check if tournament exists
    async function checkTournamentExists(categoryId, tournamentNumber, season) {
      try {
        const response = await fetch(
          `${API_URL}/tournaments/check-exists?categoryId=${categoryId}&tournamentNumber=${tournamentNumber}&season=${encodeURIComponent(season)}`,
          { headers: { 'Authorization': `Bearer ${token}` } }
        );
        if (response.ok) {
          return await response.json();
        }
      } catch (error) {
        console.error('Error checking tournament:', error);
      }
      return { exists: false };
    }

    // Perform the actual import
    async function performImport(formData) {
      const errorDiv = document.getElementById('errorMessage');
      const successDiv = document.getElementById('successMessage');
      const importBtn = document.getElementById('importBtn');

      // Get category ID for the link
      const categoryId = document.getElementById('categorySelect').value;

      try {
        const response = await fetch(`${API_URL}/tournaments/import`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`
          },
          body: formData
        });

        const data = await response.json();

        if (response.ok) {
          successDiv.textContent = `Import r√©ussi ! ${data.imported} r√©sultats import√©s. Les classements ont √©t√© recalcul√©s.`;
          successDiv.style.display = 'block';

          // Show results
          const resultsCard = document.getElementById('resultsCard');
          const resultsDiv = document.getElementById('importResults');

          resultsDiv.innerHTML = `
            <div class="stats-grid">
              <div class="stat-card">
                <h4>R√©sultats import√©s</h4>
                <div class="stat-value">${data.imported}</div>
              </div>
            </div>
            <p style="margin-top: 20px;">
              <a href="rankings.html?categoryId=${categoryId}" class="btn btn-small">Voir les classements mis √† jour</a>
            </p>
          `;

          if (data.errors && data.errors.length > 0) {
            resultsDiv.innerHTML += `
              <div class="error" style="margin-top: 20px;">
                <strong>Erreurs rencontr√©es :</strong>
                <ul style="margin-top: 10px;">
                  ${data.errors.slice(0, 10).map(err => `<li>${err.licence || err.record}: ${err.error}</li>`).join('')}
                </ul>
              </div>
            `;
          }

          resultsCard.style.display = 'block';

          // Reset form
          fileInput.value = '';
          fileName.style.display = 'none';
          document.getElementById('importForm').reset();

          // Ask if user wants to send results email
          if (data.tournamentId && data.imported > 0) {
            setTimeout(() => {
              showSendResultsPopup(data.tournamentId, categoryId);
            }, 500);
          }
        } else {
          errorDiv.textContent = data.error || 'Erreur lors de l\'import';
          errorDiv.style.display = 'block';
        }
      } catch (error) {
        errorDiv.textContent = 'Erreur de connexion au serveur';
        errorDiv.style.display = 'block';
      } finally {
        importBtn.disabled = false;
        importBtn.textContent = 'Enregistrer la competition';
      }
    }

    // Proceed with validation (after overwrite confirmation or if no existing tournament)
    async function proceedWithValidation() {
      const errorDiv = document.getElementById('errorMessage');
      const importBtn = document.getElementById('importBtn');

      importBtn.textContent = 'Validation en cours...';

      try {
        // Validate and check for unknown players
        const validateResponse = await fetch(`${API_URL}/tournaments/validate`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`
          },
          body: currentFormData
        });

        const validateData = await validateResponse.json();

        if (!validateResponse.ok) {
          throw new Error(validateData.error || 'Erreur lors de la validation');
        }

        if (validateData.status === 'validation_required' && validateData.unknownPlayers.length > 0) {
          // Show modal for unknown players
          importBtn.textContent = 'En attente de cr√©ation des joueurs...';
          showUnknownPlayersModal(validateData.unknownPlayers);
        } else {
          // All players exist, proceed with import
          importBtn.textContent = 'Import en cours...';
          await performImport(currentFormData);
        }

      } catch (error) {
        errorDiv.textContent = error.message || 'Erreur de connexion au serveur';
        errorDiv.style.display = 'block';
        importBtn.disabled = false;
        importBtn.textContent = 'Enregistrer la competition';
      }
    }

    // Form submission - branch based on qualification mode
    document.getElementById('importForm').addEventListener('submit', async (e) => {
      e.preventDefault();

      const errorDiv = document.getElementById('errorMessage');
      const successDiv = document.getElementById('successMessage');
      const importBtn = document.getElementById('importBtn');

      errorDiv.style.display = 'none';
      successDiv.style.display = 'none';

      const categoryId = document.getElementById('categorySelect').value;
      const tournamentNumber = document.getElementById('tournamentNumber').value;
      const tournamentDate = document.getElementById('tournamentDate').value;
      const season = document.getElementById('season').value;

      if (!categoryId || !tournamentNumber || !tournamentDate || !season) {
        errorDiv.textContent = 'Veuillez remplir tous les champs';
        errorDiv.style.display = 'block';
        return;
      }

      // Branch based on qualification mode
      if (window.qualificationMode === 'journees') {
        await handleJourneesSubmit(categoryId, tournamentNumber, tournamentDate, season);
      } else {
        await handleStandardSubmit(categoryId, tournamentNumber, tournamentDate, season);
      }
    });

    // Handle standard mode submit (single file)
    async function handleStandardSubmit(categoryId, tournamentNumber, tournamentDate, season) {
      const errorDiv = document.getElementById('errorMessage');
      const importBtn = document.getElementById('importBtn');

      if (!fileInput.files[0]) {
        errorDiv.textContent = 'Veuillez s√©lectionner un fichier CSV';
        errorDiv.style.display = 'block';
        return;
      }

      const formData = new FormData();
      formData.append('file', fileInput.files[0]);
      formData.append('categoryId', categoryId);
      formData.append('tournamentNumber', tournamentNumber);
      formData.append('tournamentDate', tournamentDate);
      formData.append('season', season);

      currentFormData = formData;

      importBtn.disabled = true;
      importBtn.textContent = 'V√©rification...';

      try {
        const existsResult = await checkTournamentExists(categoryId, tournamentNumber, season);

        if (existsResult.exists) {
          showExistingTournamentModal(existsResult.tournament);
        } else {
          await proceedWithValidation();
        }
      } catch (error) {
        errorDiv.textContent = error.message || 'Erreur de connexion au serveur';
        errorDiv.style.display = 'block';
        importBtn.disabled = false;
        importBtn.textContent = 'Enregistrer la competition';
      }
    }

    // ========== JOURNEES MODE FUNCTIONS ==========

    // Qualification mode state
    window.qualificationMode = 'standard';
    let selectedFiles = [];
    let lastImportedTournamentId = null;

    // Load qualification mode from org settings
    async function loadQualificationMode() {
      try {
        const response = await fetch(`${API_URL}/settings/app-all`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
          const settings = await response.json();
          window.singlePouleThreshold = settings.single_poule_threshold || '6';
          if (settings.qualification_mode === 'journees') {
            window.qualificationMode = 'journees';
            switchToJourneesMode();
          }
        }
      } catch (error) {
        console.error('Error loading qualification mode:', error);
      }
    }

    // Phase definitions for journ√©es mode
    const PHASES_SMALL = [
      { key: 'POULES', label: 'Poule unique (tour complet)', icon: 'üéØ', required: true }
    ];
    const PHASES_BRACKET = [
      { key: 'POULES', label: 'Poules', icon: 'üéØ', required: true },
      { key: 'Demi-finales', label: 'Demi-finales', icon: '‚öîÔ∏è', required: true },
      { key: 'Finale', label: 'Finale', icon: 'üèÜ', required: true },
      { key: 'Petite finale', label: 'Petite finale', icon: 'ü•â', required: true },
      { key: 'CLASSEMENTS', label: 'Classements', icon: 'üìä', required: false }
    ];

    // Per-phase file mapping: { phaseKey: File }
    window.phaseFiles = {};

    // Switch UI to journees mode
    function switchToJourneesMode() {
      document.getElementById('fileUpload').style.display = 'none';
      document.getElementById('fileInput').removeAttribute('required');
      document.getElementById('journeesUpload').style.display = 'block';

      document.getElementById('importCardTitle').textContent = "Enregistrer les r√©sultats d'une journ√©e qualificative";
      document.getElementById('importCardDescription').textContent =
        "S√©lectionnez la cat√©gorie, le num√©ro du tournoi et la saison, indiquez le nombre de joueurs, puis importez le fichier CSV de chaque phase.";
    }

    // Update phase blocs based on player count
    function updatePhaseBlocs() {
      const count = parseInt(document.getElementById('playerCountInput').value) || 0;
      const container = document.getElementById('phaseBlocsContainer');
      const hint = document.getElementById('phaseHint');
      const singlePouleThreshold = parseInt(window.singlePouleThreshold || '6');

      if (count < 2) {
        container.style.display = 'none';
        hint.textContent = '';
        window.phaseFiles = {};
        selectedFiles = [];
        return;
      }

      container.style.display = 'block';
      const phases = count < singlePouleThreshold ? PHASES_SMALL : PHASES_BRACKET;

      if (count < singlePouleThreshold) {
        hint.textContent = `< ${singlePouleThreshold} joueurs ‚Üí poule unique, pas de tableau`;
      } else {
        hint.textContent = `‚â• ${singlePouleThreshold} joueurs ‚Üí poules + tableau final`;
      }

      // Reset files for phases that no longer exist
      const validKeys = phases.map(p => p.key);
      Object.keys(window.phaseFiles).forEach(k => {
        if (!validKeys.includes(k)) delete window.phaseFiles[k];
      });
      rebuildSelectedFiles();

      const blocsDiv = document.getElementById('phaseBlocs');
      blocsDiv.innerHTML = phases.map(phase => {
        const file = window.phaseFiles[phase.key];
        const hasFile = !!file;
        return `
          <div id="phaseBloc-${phase.key}" style="display: flex; align-items: center; gap: 12px; padding: 12px 16px; margin-bottom: 8px; background: ${hasFile ? '#d4edda' : '#f8f9fa'}; border: 2px ${hasFile ? 'solid #28a745' : 'dashed #ccc'}; border-radius: 8px; transition: all 0.2s ease; cursor: pointer;"
               ondragover="event.preventDefault(); this.style.background='#e7f3ff'; this.style.borderColor='var(--color-primary, #1F4788)';"
               ondragleave="this.style.background='${hasFile ? '#d4edda' : '#f8f9fa'}'; this.style.borderColor='${hasFile ? '#28a745' : '#ccc'}';"
               ondrop="handlePhaseDrop(event, '${phase.key}')"
               onclick="triggerPhaseFileInput('${phase.key}')">
            <span style="font-size: 20px;">${phase.icon}</span>
            <div style="flex: 1;">
              <div style="font-weight: 600; font-size: 14px;">${phase.label}${phase.required ? ' *' : ''}</div>
              ${hasFile
                ? `<div style="color: #28a745; font-size: 12px; margin-top: 2px;">‚úì ${file.name}</div>`
                : `<div style="color: #999; font-size: 12px; margin-top: 2px;">Cliquez ou glissez un fichier CSV</div>`
              }
            </div>
            ${hasFile
              ? `<button type="button" onclick="event.stopPropagation(); removePhaseFile('${phase.key}')" style="background: none; border: none; color: #dc3545; cursor: pointer; font-size: 18px; padding: 4px;" title="Retirer">‚úï</button>`
              : `<span style="color: #999; font-size: 20px;">üìÅ</span>`
            }
          </div>
        `;
      }).join('');
    }

    // Handle drag & drop on a specific phase bloc
    function handlePhaseDrop(event, phaseKey) {
      event.preventDefault();
      event.stopPropagation();
      const files = event.dataTransfer.files;
      if (files.length > 0) {
        window.phaseFiles[phaseKey] = files[0];
        rebuildSelectedFiles();
        updatePhaseBlocs();
      }
    }

    // Trigger file input for a specific phase
    function triggerPhaseFileInput(phaseKey) {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.csv';
      input.onchange = () => {
        if (input.files.length > 0) {
          window.phaseFiles[phaseKey] = input.files[0];
          rebuildSelectedFiles();
          updatePhaseBlocs();
        }
      };
      input.click();
    }

    // Remove file from a phase
    function removePhaseFile(phaseKey) {
      delete window.phaseFiles[phaseKey];
      rebuildSelectedFiles();
      updatePhaseBlocs();
    }

    // Rebuild selectedFiles array from phaseFiles map (for backend compatibility)
    function rebuildSelectedFiles() {
      selectedFiles = Object.values(window.phaseFiles);
    }

    // Detect phase from filename (mirrors backend) ‚Äî kept for backend compatibility
    function detectPhaseFromFilename(filename) {
      const lower = filename.toLowerCase();
      const match = lower.match(/classement[_ ]phase[_ ](.+?)\.csv$/i);
      if (match) return match[1].trim();
      if (lower.includes('poule')) return 'POULES';
      if (lower.includes('petite') && lower.includes('finale')) return 'Petite finale';
      if (lower.includes('demi')) return 'Demi-finales';
      if (lower.includes('finale')) return 'Finale';
      if (lower.includes('classement')) return 'CLASSEMENTS';
      return filename.replace('.csv', '');
    }

    // Handle journees mode form submission
    async function handleJourneesSubmit(categoryId, tournamentNumber, tournamentDate, season) {
      const errorDiv = document.getElementById('errorMessage');
      const importBtn = document.getElementById('importBtn');

      if (selectedFiles.length === 0) {
        errorDiv.textContent = 'Veuillez ajouter au moins un fichier CSV';
        errorDiv.style.display = 'block';
        return;
      }

      if (!window.phaseFiles['POULES']) {
        errorDiv.textContent = 'Le fichier POULES est obligatoire. Veuillez ajouter le fichier CSV de la phase POULES.';
        errorDiv.style.display = 'block';
        return;
      }

      importBtn.disabled = true;
      importBtn.textContent = 'V√©rification...';

      try {
        const existsResult = await checkTournamentExists(categoryId, tournamentNumber, season);

        if (existsResult.exists) {
          showExistingTournamentModal(existsResult.tournament);
          // Override confirm button for journees mode
          document.getElementById('confirmOverwriteBtn').onclick = async () => {
            hideExistingTournamentModal();
            await proceedWithJourneesValidation(categoryId, tournamentNumber, tournamentDate, season);
          };
        } else {
          await proceedWithJourneesValidation(categoryId, tournamentNumber, tournamentDate, season);
        }
      } catch (error) {
        errorDiv.textContent = error.message || 'Erreur de connexion au serveur';
        errorDiv.style.display = 'block';
        importBtn.disabled = false;
        importBtn.textContent = 'Enregistrer la competition';
      }
    }

    // Validate journees files (check unknown players across all files)
    async function proceedWithJourneesValidation(categoryId, tournamentNumber, tournamentDate, season) {
      const errorDiv = document.getElementById('errorMessage');
      const importBtn = document.getElementById('importBtn');

      importBtn.textContent = 'Validation en cours...';

      try {
        const valFormData = new FormData();
        for (const [phaseKey, file] of Object.entries(window.phaseFiles)) {
          const phaseName = phaseKey.replace(/ /g, '_');
          const renamedFile = new File([file], `classement_phase_${phaseName}.csv`, { type: file.type });
          valFormData.append('files', renamedFile);
        }
        valFormData.append('categoryId', categoryId);

        const validateResponse = await fetch(`${API_URL}/tournaments/validate-journee`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` },
          body: valFormData
        });

        const validateData = await validateResponse.json();

        if (!validateResponse.ok) {
          throw new Error(validateData.error || 'Erreur lors de la validation');
        }

        if (validateData.status === 'validation_required' && validateData.unknownPlayers && validateData.unknownPlayers.length > 0) {
          importBtn.textContent = 'En attente de cr√©ation des joueurs...';
          showUnknownPlayersModal(validateData.unknownPlayers);

          // Override create players button for journees mode
          document.getElementById('createPlayersBtn').onclick = async () => {
            const playersToCreate = unknownPlayers.map((player, index) => {
              const clubSelect = document.getElementById(`club_${index}`);
              if (!clubSelect.value) {
                throw new Error(`Veuillez s√©lectionner un club pour ${player.fullName}`);
              }
              return {
                licence: player.licence,
                firstName: player.firstName,
                lastName: player.lastName,
                club: clubSelect.value
              };
            });

            try {
              const createResponse = await fetch(`${API_URL}/tournaments/create-players`, {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${token}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({ players: playersToCreate })
              });

              if (!createResponse.ok) {
                throw new Error('Erreur lors de la cr√©ation des joueurs');
              }

              hideModal();
              await performJourneesImport(categoryId, tournamentNumber, tournamentDate, season);
            } catch (error) {
              alert(error.message || 'Erreur lors de la cr√©ation des joueurs');
            }
          };
        } else {
          await performJourneesImport(categoryId, tournamentNumber, tournamentDate, season);
        }
      } catch (error) {
        errorDiv.textContent = error.message || 'Erreur de connexion au serveur';
        errorDiv.style.display = 'block';
        importBtn.disabled = false;
        importBtn.textContent = 'Enregistrer la competition';
      }
    }

    // Perform the actual journees import
    async function performJourneesImport(categoryId, tournamentNumber, tournamentDate, season) {
      const errorDiv = document.getElementById('errorMessage');
      const successDiv = document.getElementById('successMessage');
      const importBtn = document.getElementById('importBtn');

      importBtn.textContent = 'Import en cours...';

      try {
        const formData = new FormData();
        // Append files with phase-aware names so backend can detect phases
        for (const [phaseKey, file] of Object.entries(window.phaseFiles)) {
          const phaseName = phaseKey.replace(/ /g, '_');
          const renamedFile = new File([file], `classement_phase_${phaseName}.csv`, { type: file.type });
          formData.append('files', renamedFile);
        }
        formData.append('categoryId', categoryId);
        formData.append('tournamentNumber', tournamentNumber);
        formData.append('tournamentDate', tournamentDate);
        formData.append('season', season);

        const response = await fetch(`${API_URL}/tournaments/import-journee`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` },
          body: formData
        });

        const data = await response.json();

        if (response.ok) {
          successDiv.textContent = `Import r√©ussi ! ${data.imported} r√©sultats import√©s. Les classements ont √©t√© recalcul√©s.`;
          successDiv.style.display = 'block';

          lastImportedTournamentId = data.tournamentId;

          const resultsCard = document.getElementById('resultsCard');
          const resultsDiv = document.getElementById('importResults');

          let positionsHtml = '';
          if (data.positions && data.positions.length > 0) {
            positionsHtml = `
              <h4 style="margin-top: 20px; margin-bottom: 10px;">Classement final :</h4>
              <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
                <thead>
                  <tr style="background: var(--color-primary, #1F4788); color: white;">
                    <th style="padding: 8px; text-align: center;">Pos.</th>
                    <th style="padding: 8px; text-align: left;">Joueur</th>
                    <th style="padding: 8px; text-align: center;">Pts Position</th>
                  </tr>
                </thead>
                <tbody>
                  ${data.positions.map(p => `
                    <tr style="border-bottom: 1px solid #eee;">
                      <td style="padding: 8px; text-align: center; font-weight: bold;">${p.position}</td>
                      <td style="padding: 8px;">${p.playerName || p.licence}</td>
                      <td style="padding: 8px; text-align: center;">${p.positionPoints || 0}</td>
                    </tr>
                  `).join('')}
                </tbody>
              </table>
            `;
          }

          let phasesHtml = '';
          if (data.phases && data.phases.length > 0) {
            phasesHtml = `
              <div style="margin-top: 15px;">
                <strong>Phases import√©es :</strong> ${data.phases.join(', ')}
              </div>
            `;
          }

          resultsDiv.innerHTML = `
            <div class="stats-grid">
              <div class="stat-card">
                <h4>R√©sultats import√©s</h4>
                <div class="stat-value">${data.imported}</div>
              </div>
              <div class="stat-card">
                <h4>Phases trait√©es</h4>
                <div class="stat-value">${data.phasesCount || (data.phases ? data.phases.length : 0)}</div>
              </div>
            </div>
            ${phasesHtml}
            ${positionsHtml}
            <p style="margin-top: 20px;">
              <a href="rankings.html?categoryId=${categoryId}" class="btn btn-small">Voir les classements mis √† jour</a>
            </p>
          `;

          if (data.errors && data.errors.length > 0) {
            resultsDiv.innerHTML += `
              <div class="error" style="margin-top: 20px;">
                <strong>Erreurs rencontr√©es :</strong>
                <ul style="margin-top: 10px;">
                  ${data.errors.slice(0, 10).map(err => `<li>${err.licence || err.record}: ${err.error}</li>`).join('')}
                </ul>
              </div>
            `;
          }

          resultsCard.style.display = 'block';

          // Reset files
          selectedFiles = [];
          window.phaseFiles = {};
          document.getElementById('importForm').reset();
          document.getElementById('phaseBlocsContainer').style.display = 'none';
          document.getElementById('playerCountInput').value = '';

          // Check if mixed-category bonus is enabled
          if (data.mixedCategoryBonus && data.tournamentId) {
            setTimeout(() => showCategoryBonusStep(data.tournamentId, categoryId), 500);
          } else if (data.tournamentId && data.imported > 0) {
            setTimeout(() => showSendResultsPopup(data.tournamentId, categoryId), 500);
          }
        } else {
          errorDiv.textContent = data.error || "Erreur lors de l'import";
          errorDiv.style.display = 'block';
        }
      } catch (error) {
        errorDiv.textContent = 'Erreur de connexion au serveur';
        errorDiv.style.display = 'block';
      } finally {
        importBtn.disabled = false;
        importBtn.textContent = 'Enregistrer la competition';
      }
    }

    // Show mixed-category bonus entry step
    async function showCategoryBonusStep(tournamentId, categoryId) {
      const bonusCard = document.getElementById('categoryBonusCard');
      const bonusBody = document.getElementById('categoryBonusBody');
      const bonusMsg = document.getElementById('bonusMessage');

      try {
        const response = await fetch(`${API_URL}/tournaments/${tournamentId}/category-bonus`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (!response.ok) throw new Error('Erreur chargement bonus');

        const data = await response.json();
        const players = data.players || [];

        bonusBody.innerHTML = players.map(p => `
          <tr style="border-bottom: 1px solid #eee;">
            <td style="padding: 10px;">${p.player_name || ''}</td>
            <td style="padding: 10px; text-align: center;">${p.licence || ''}</td>
            <td style="padding: 10px; text-align: center;">${p.ffb_ranking || 'NC'}</td>
            <td style="padding: 10px; text-align: center;">${p.position || '-'}</td>
            <td style="padding: 10px; text-align: center;">
              <input type="number" min="0" max="${p.match_points || 10}" value="0"
                data-licence="${p.licence}"
                style="width: 60px; padding: 4px; text-align: center; border: 1px solid #ddd; border-radius: 4px;">
            </td>
          </tr>
        `).join('');

        bonusCard.style.display = 'block';
        bonusCard.scrollIntoView({ behavior: 'smooth' });

        // Save bonus button
        document.getElementById('saveBonusBtn').onclick = async () => {
          const bonuses = [];
          bonusBody.querySelectorAll('input[data-licence]').forEach(input => {
            const bonus = parseInt(input.value) || 0;
            if (bonus > 0) {
              bonuses.push({ licence: input.dataset.licence, bonus_points: bonus });
            }
          });

          try {
            const saveResponse = await fetch(`${API_URL}/tournaments/${tournamentId}/category-bonus`, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ bonuses })
            });

            if (saveResponse.ok) {
              bonusMsg.textContent = 'Bonus enregistr√©s et classements recalcul√©s.';
              bonusMsg.style.display = 'block';
              bonusMsg.style.background = '#d4edda';
              bonusMsg.style.color = '#155724';

              setTimeout(() => {
                showSendResultsPopup(tournamentId, categoryId);
              }, 1000);
            } else {
              throw new Error('Erreur sauvegarde');
            }
          } catch (err) {
            bonusMsg.textContent = 'Erreur lors de la sauvegarde des bonus.';
            bonusMsg.style.display = 'block';
            bonusMsg.style.background = '#f8d7da';
            bonusMsg.style.color = '#721c24';
          }
        };

        // Skip bonus button
        document.getElementById('skipBonusBtn').onclick = () => {
          bonusCard.style.display = 'none';
          showSendResultsPopup(tournamentId, categoryId);
        };
      } catch (error) {
        console.error('Error loading bonus data:', error);
        showSendResultsPopup(tournamentId, categoryId);
      }
    }

    // Initialize
    loadCategories();
    loadClubs();
    loadQualificationMode();

    // Set today's date as default value
    const today = new Date().toISOString().split('T')[0];
    document.getElementById('tournamentDate').value = today;

    // Auto-calculate season for today's date
    const season = calculateSeason(today);
    document.getElementById('season').value = season;

    // Logout handler
    document.getElementById('logoutBtn').addEventListener('click', (e) => {
      e.preventDefault();
      localStorage.removeItem('token');
      localStorage.removeItem('userRole');
      window.location.href = 'login.html';
    });

    // Show send results popup
    function showSendResultsPopup(tournamentId, categoryId) {
      const modal = document.getElementById('sendResultsModal');
      modal.style.display = 'flex';

      // Handle Yes button - redirect to emailing page
      document.getElementById('sendResultsYesBtn').onclick = () => {
        modal.style.display = 'none';
        // Redirect to emailing page with tournament pre-selected
        window.location.href = `emailing.html?tab=results&tournamentId=${tournamentId}`;
      };

      // Handle No button - just close
      document.getElementById('sendResultsNoBtn').onclick = () => {
        modal.style.display = 'none';
      };
    }
  </script>
</body>
</html>
