<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Import Tournoi - Billard Ranking</title>
  <link rel="icon" type="image/png" href="images/FrenchBillard-Icon-small.png">
  <link rel="stylesheet" href="css/styles.css">
  <script src="js/branding.js?v=197"></script>
</head>
<body>
  <div class="container">
    <div class="navbar">
      <h2><img id="app-header-icon" src="images/FrenchBillard-Icon-small.png" alt="" style="height: 48px; width: 48px; vertical-align: middle; margin-right: 8px;" onerror="this.src='images/FrenchBillard-Icon-small.png';"><span id="app-org-name" data-page-title="Import Comp√©tition">CDB</span></h2>
      <div class="nav-links">
        <a href="dashboard.html">Accueil</a>
        <a href="rankings.html" class="nav-tooltip" data-tooltip="Classement par cat√©gorie de jeu au fur et √† mesure des tournois">Classements</a>
        <a href="generate-poules.html" class="nav-tooltip" data-tooltip="Comp√©titions √† jouer / Convocations">Comp√©titions</a>
        <a href="calendar.html" class="nav-tooltip" data-tooltip="Calendrier de la saison">Calendrier</a>
        <a href="emailing.html" class="nav-tooltip" data-tooltip="Annonces, relances, r√©sultats, convocation">Com joueurs</a>
        <a href="settings.html" class="admin-only nav-tooltip" data-tooltip="R√©serv√© aux administrateurs">Param√®tres</a>
        <a href="#" id="logoutBtn" class="nav-logout">D√©connexion</a>
      </div>
    </div>

    <div id="errorMessage" class="error" style="display: none;"></div>
    <div id="successMessage" class="success" style="display: none;"></div>

    <div class="card">
      <h3 id="importCardTitle">Enregistrer les resultats d'une competition</h3>
      <p id="importCardDescription" style="color: #666; margin-bottom: 20px;">
        Selectionnez la categorie, le numero du tournoi et la saison, puis importez le fichier CSV des resultats.
      </p>

      <form id="importForm">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
          <div class="form-group">
            <label for="modeSelect">Mode de jeu *</label>
            <select id="modeSelect" required>
              <option value="">-- S√©lectionner --</option>
            </select>
          </div>
          <div class="form-group">
            <label for="levelSelect">Classement FFB *</label>
            <select id="levelSelect" required>
              <option value="">-- S√©lectionner --</option>
            </select>
            <!-- Hidden select to store the resolved category ID -->
            <select id="categorySelect" style="display: none;">
              <option value="">-- S√©lectionner une cat√©gorie --</option>
            </select>
          </div>
        </div>

        <div class="form-group">
          <label for="tournamentNumber">Num√©ro du tournoi *</label>
          <select id="tournamentNumber" required>
            <option value="">-- S√©lectionner --</option>
          </select>
        </div>

        <div class="form-group">
          <label for="tournamentDate">Date du tournoi *</label>
          <input type="date" id="tournamentDate" required>
        </div>

        <div class="form-group">
          <label for="season">Saison (calcul√©e automatiquement)</label>
          <input type="text" id="season" placeholder="Ex: 2024-2025" readonly style="background: #f0f0f0;">
        </div>

        <!-- Single file upload zone (standard mode) -->
        <div class="file-upload" id="fileUpload">
          <p>üìÅ Cliquez pour s√©lectionner un fichier CSV</p>
          <p style="font-size: 12px; color: #999; margin-top: 10px;">ou glissez-d√©posez le fichier ici</p>
          <input type="file" id="fileInput" accept=".csv" required>
          <div id="fileName" class="file-name" style="display: none;"></div>
        </div>

        <!-- Multi-file upload zone (journees mode, hidden by default) -->
        <div id="journeesUpload" style="display: none;">
          <!-- Two options: folder or individual files -->
          <div style="margin-bottom: 15px; display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
            <button type="button" onclick="document.getElementById('folderInput').click()" class="btn" style="background: var(--color-primary, #1F4788); padding: 12px 22px; font-size: 14px; display: inline-flex; align-items: center; gap: 8px;">
              üìÇ S√©lectionner le dossier E2i
            </button>
            <span style="color: #999; font-size: 13px;">ou</span>
            <button type="button" onclick="document.getElementById('multiFileInput').click()" class="btn" style="background: #6c757d; padding: 12px 22px; font-size: 14px; display: inline-flex; align-items: center; gap: 8px;">
              üìÑ S√©lectionner les fichiers
            </button>
            <input type="file" id="folderInput" webkitdirectory style="display: none;">
          </div>

          <!-- Drag & drop alternative -->
          <div class="file-upload" id="multiFileUpload" style="min-height: 80px; cursor: pointer; border: 2px dashed #ccc; border-radius: 10px; padding: 20px; text-align: center; transition: all 0.2s ease;">
            <p style="font-size: 13px; color: #999; margin: 0;">ou glissez-d√©posez les fichiers CSV ici</p>
            <input type="file" id="multiFileInput" accept=".csv" multiple style="display: none;">
          </div>

          <!-- Detected phases summary -->
          <div id="phasesSummary" style="display: none; margin-top: 15px;">
            <h4 style="margin-bottom: 10px; color: var(--color-primary, #1F4788);">Phases d√©tect√©es :</h4>
            <div id="phasesList"></div>
          </div>
        </div>

        <button type="submit" class="btn" id="importBtn">Enregistrer la competition</button>
      </form>
    </div>

    <!-- Preview card (journees mode ‚Äî shown before final import) -->
    <div class="card" id="previewCard" style="display: none;">
      <h3>Aper√ßu du classement</h3>
      <p style="color: #666; font-size: 13px; margin-bottom: 15px;">
        V√©rifiez les positions et points avant d'enregistrer la comp√©tition.
      </p>
      <div id="previewContent"></div>
      <div style="display: flex; gap: 10px; margin-top: 15px;">
        <button class="btn" id="confirmImportBtn">Valider le classement</button>
        <button class="btn" id="cancelPreviewBtn" style="background: #6c757d;">Annuler</button>
      </div>
    </div>

    <!-- Allocation card ‚Äî final ranking with position points before import -->
    <div class="card" id="allocationCard" style="display: none;">
      <h3>Attribution des Points Position</h3>
      <p style="color: #666; font-size: 13px; margin-bottom: 15px;">
        Classement final de la journ√©e. V√©rifiez l'attribution des points avant d'enregistrer.
      </p>
      <div id="allocationContent"></div>
      <div style="display: flex; gap: 10px; margin-top: 15px;">
        <button class="btn" id="confirmAllocationBtn">Enregistrer la journ√©e</button>
        <button class="btn" id="backToPreviewBtn" style="background: #6c757d;">Retour √† l'aper√ßu</button>
      </div>
    </div>

    <div class="card" id="resultsCard" style="display: none;">
      <h3>R√©sultats de l'import</h3>
      <div id="importResults"></div>
    </div>

    <!-- Mixed-category bonus card (journees mode only) -->
    <div class="card" id="categoryBonusCard" style="display: none;">
      <h3>Bonus categories mixtes</h3>
      <div style="margin-bottom: 15px; padding: 12px; background: #e7f3ff; border-left: 4px solid var(--color-primary, #1F4788); border-radius: 4px;">
        <strong>Information :</strong> Ajoutez +1 point par match joue contre un adversaire d'une categorie superieure.
      </div>
      <div style="overflow-x: auto;">
        <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
          <thead>
            <tr style="background: var(--color-primary, #1F4788); color: white;">
              <th style="padding: 10px; text-align: left;">Joueur</th>
              <th style="padding: 10px; text-align: center;">Licence</th>
              <th style="padding: 10px; text-align: center;">Classement FFB</th>
              <th style="padding: 10px; text-align: center;">Position</th>
              <th style="padding: 10px; text-align: center;">Bonus (+1/match)</th>
            </tr>
          </thead>
          <tbody id="categoryBonusBody">
          </tbody>
        </table>
      </div>
      <div style="display: flex; gap: 10px; margin-top: 20px;">
        <button id="saveBonusBtn" class="btn" style="flex: 1; background: #28a745;">Enregistrer les bonus</button>
        <button id="skipBonusBtn" class="btn" style="flex: 1; background: #6c757d;">Passer</button>
      </div>
      <div id="bonusMessage" style="display: none; margin-top: 15px; padding: 10px; border-radius: 4px;"></div>
    </div>

    <!-- Modal for unknown players -->
    <div id="unknownPlayersModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
      <div style="background: white; padding: 30px; border-radius: 12px; max-width: 600px; max-height: 80vh; overflow-y: auto; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
        <h3 style="margin-top: 0;">‚ö†Ô∏è Joueurs inconnus d√©tect√©s</h3>
        <p style="color: #666; margin-bottom: 20px;">Les joueurs suivants n'existent pas dans la base de donn√©es. Veuillez s√©lectionner leur club pour les cr√©er.</p>
        <div id="unknownPlayersList"></div>
        <div style="display: flex; gap: 10px; margin-top: 20px;">
          <button id="createPlayersBtn" class="btn" style="flex: 1;">Cr√©er les joueurs et continuer</button>
          <button id="cancelBtn" class="btn" style="flex: 1; background: #999;">Annuler</button>
        </div>
      </div>
    </div>

    <!-- Modal for existing tournament warning -->
    <div id="existingTournamentModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
      <div style="background: white; padding: 30px; border-radius: 12px; max-width: 500px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
        <h3 style="margin-top: 0; color: #dc3545;">‚ö†Ô∏è Tournoi existant</h3>
        <p style="color: #666; margin-bottom: 15px;">Un tournoi existe d√©j√† pour cette cat√©gorie/num√©ro/saison :</p>
        <div id="existingTournamentInfo" style="background: #fff3cd; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ffc107;">
        </div>
        <p style="color: #dc3545; font-weight: bold; margin-bottom: 20px;">
          En continuant, les r√©sultats existants seront d√©finitivement remplac√©s !
        </p>
        <div style="display: flex; gap: 10px;">
          <button id="confirmOverwriteBtn" class="btn" style="flex: 1; background: #dc3545;">Remplacer le tournoi</button>
          <button id="cancelOverwriteBtn" class="btn" style="flex: 1; background: #6c757d;">Annuler</button>
        </div>
      </div>
    </div>

    <!-- Modal for sending results email -->
    <div id="sendResultsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
      <div style="background: white; padding: 30px; border-radius: 12px; max-width: 450px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); text-align: center;">
        <div style="font-size: 48px; margin-bottom: 15px;">üìß</div>
        <h3 style="margin-top: 0; color: #1F4788;">Envoyer les r√©sultats ?</h3>
        <p style="color: #666; margin-bottom: 25px;">
          Voulez-vous envoyer les r√©sultats du tournoi par email aux participants ?
        </p>
        <div style="display: flex; gap: 10px;">
          <button id="sendResultsYesBtn" class="btn" style="flex: 1; background: #28a745;">Oui, envoyer</button>
          <button id="sendResultsNoBtn" class="btn" style="flex: 1; background: #6c757d;">Plus tard</button>
        </div>
        <p style="font-size: 12px; color: #999; margin-top: 15px;">
          Vous pourrez envoyer les r√©sultats plus tard depuis la page Comp√©titions Jou√©es
        </p>
      </div>
    </div>
  </div>

  <script src="js/auth-utils.js?v=197"></script>
  <script src="js/app-branding.js?v=215"></script>
  <script>
    const API_URL = '/api';

    // Check authentication
    if (!requireAuth()) {
      throw new Error('Not authenticated'); // Stop script execution
    }
    const token = localStorage.getItem('token');

    // Check user role - this page is admin only
    const userRole = localStorage.getItem('userRole');
    if (userRole !== 'admin') {
      alert('Acc√®s r√©serv√© aux administrateurs');
      window.location.href = 'dashboard.html';
    }


    // Calculate season from tournament date
    // September to July determines the season
    // Example: Oct 2025 ‚Üí 2025-2026, July 2026 ‚Üí 2025-2026, Sept 2026 ‚Üí 2026-2027
    function calculateSeason(dateString) {
      const date = new Date(dateString);
      const month = date.getMonth() + 1; // 1-12
      const year = date.getFullYear();

      // If month is September (9) or later, season starts this year
      // If month is before September, season started last year
      const startYear = month >= 9 ? year : year - 1;
      const endYear = startYear + 1;

      return `${startYear}-${endYear}`;
    }

    // Update season when tournament date changes
    document.getElementById('tournamentDate').addEventListener('change', (e) => {
      const date = e.target.value;
      if (date) {
        const season = calculateSeason(date);
        document.getElementById('season').value = season;
      }
    });

    // Load categories
    async function loadCategories() {
      try {
        const response = await fetch(`${API_URL}/tournaments/categories`, {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        if (response.ok) {
          categories = await response.json();

          // Populate mode selector with unique game types
          const modes = [...new Set(categories.map(c => c.game_type))].sort();
          const modeSelect = document.getElementById('modeSelect');
          modeSelect.innerHTML = '<option value="">-- S√©lectionner --</option>';
          modes.forEach(mode => {
            modeSelect.innerHTML += `<option value="${mode}">${mode}</option>`;
          });

          // Keep hidden categorySelect for compatibility
          const select = document.getElementById('categorySelect');
          select.innerHTML = '<option value="">-- S√©lectionner une cat√©gorie --</option>';
          categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.id;
            option.textContent = category.display_name;
            select.appendChild(option);
          });
        }
      } catch (error) {
        console.error('Error loading categories:', error);
      }
    }

    // Mode selector change - populate levels
    document.getElementById('modeSelect').addEventListener('change', (e) => {
      const selectedMode = e.target.value;
      const levelSelect = document.getElementById('levelSelect');
      const categorySelect = document.getElementById('categorySelect');

      levelSelect.innerHTML = '<option value="">-- S√©lectionner --</option>';
      categorySelect.value = '';

      if (selectedMode) {
        // Filter categories by selected mode and get unique levels
        const levels = categories
          .filter(c => c.game_type === selectedMode)
          .map(c => c.level)
          .filter((v, i, a) => a.indexOf(v) === i)
          .sort();

        levels.forEach(level => {
          levelSelect.innerHTML += `<option value="${level}">${level}</option>`;
        });
      }
    });

    // Level selector change - set category
    document.getElementById('levelSelect').addEventListener('change', (e) => {
      const selectedMode = document.getElementById('modeSelect').value;
      const selectedLevel = e.target.value;
      const categorySelect = document.getElementById('categorySelect');

      if (selectedMode && selectedLevel) {
        // Find the matching category
        const matchingCategory = categories.find(c =>
          c.game_type === selectedMode && c.level === selectedLevel
        );
        if (matchingCategory) {
          categorySelect.value = matchingCategory.id;
        }
      } else {
        categorySelect.value = '';
      }

      lookupTournamentDate();
    });

    // Tournament number change ‚Äî also try to auto-fill date
    document.getElementById('tournamentNumber').addEventListener('change', () => {
      lookupTournamentDate();
    });

    // Auto-fill tournament date from tournoi_ext (planned tournaments)
    async function lookupTournamentDate() {
      const mode = document.getElementById('modeSelect').value;
      const level = document.getElementById('levelSelect').value;
      const tournamentNumber = document.getElementById('tournamentNumber').value;

      if (!mode || !level || !tournamentNumber) return;

      try {
        const response = await fetch(
          `${API_URL}/tournaments/lookup-date?mode=${encodeURIComponent(mode)}&categorie=${encodeURIComponent(level)}&tournamentNumber=${encodeURIComponent(tournamentNumber)}`,
          { headers: { 'Authorization': `Bearer ${token}` } }
        );
        if (response.ok) {
          const data = await response.json();
          if (data.found && data.date) {
            document.getElementById('tournamentDate').value = data.date;
            // Trigger season auto-calculation
            document.getElementById('tournamentDate').dispatchEvent(new Event('change'));
          }
        }
      } catch (error) {
        // Silently fail ‚Äî date field remains editable for manual entry
      }
    }

    // File upload handling
    const fileUpload = document.getElementById('fileUpload');
    const fileInput = document.getElementById('fileInput');
    const fileName = document.getElementById('fileName');

    fileUpload.addEventListener('click', () => {
      fileInput.click();
    });

    fileUpload.addEventListener('dragover', (e) => {
      e.preventDefault();
      fileUpload.style.background = '#f0f0f0';
    });

    fileUpload.addEventListener('dragleave', () => {
      fileUpload.style.background = '';
    });

    fileUpload.addEventListener('drop', (e) => {
      e.preventDefault();
      fileUpload.style.background = '';

      if (e.dataTransfer.files.length > 0) {
        fileInput.files = e.dataTransfer.files;
        fileName.textContent = e.dataTransfer.files[0].name;
        fileName.style.display = 'block';
      }
    });

    fileInput.addEventListener('change', () => {
      if (fileInput.files.length > 0) {
        fileName.textContent = fileInput.files[0].name;
        fileName.style.display = 'block';
      }
    });

    // Global variables for import
    let clubs = [];
    let categories = [];
    let unknownPlayers = [];
    let currentFormData = null;
    let isSubmitting = false;

    // Load clubs for dropdown
    async function loadClubs() {
      try {
        const response = await fetch(`${API_URL}/clubs`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
          clubs = await response.json();
        }
      } catch (error) {
        console.error('Error loading clubs:', error);
      }
    }

    // Show unknown players modal
    function showUnknownPlayersModal(players) {
      unknownPlayers = players;
      const modal = document.getElementById('unknownPlayersModal');
      const list = document.getElementById('unknownPlayersList');

      list.innerHTML = players.map((player, index) => `
        <div style="margin-bottom: 20px; padding: 15px; background: #f9f9f9; border-radius: 8px;">
          <div style="font-weight: bold; margin-bottom: 8px;">
            ${player.fullName} (${player.licence})
          </div>
          <label style="display: block; margin-bottom: 5px; font-size: 14px; color: #666;">Club *</label>
          <select id="club_${index}" required style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">-- S√©lectionner un club --</option>
            ${clubs.map(club => `<option value="${club.name}">${club.display_name}</option>`).join('')}
          </select>
        </div>
      `).join('');

      modal.style.display = 'flex';
    }

    // Hide modal
    function hideModal() {
      document.getElementById('unknownPlayersModal').style.display = 'none';
    }

    // Create players and continue import
    document.getElementById('createPlayersBtn').addEventListener('click', async () => {
      const playersToCreate = unknownPlayers.map((player, index) => {
        const clubSelect = document.getElementById(`club_${index}`);
        if (!clubSelect.value) {
          throw new Error(`Veuillez s√©lectionner un club pour ${player.fullName}`);
        }
        return {
          licence: player.licence,
          firstName: player.firstName,
          lastName: player.lastName,
          club: clubSelect.value
        };
      });

      try {
        // Create players
        const createResponse = await fetch(`${API_URL}/tournaments/create-players`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ players: playersToCreate })
        });

        if (!createResponse.ok) {
          throw new Error('Erreur lors de la cr√©ation des joueurs');
        }

        hideModal();

        // Now proceed with the actual import
        await performImport(currentFormData);

      } catch (error) {
        alert(error.message || 'Erreur lors de la cr√©ation des joueurs');
      }
    });

    // Cancel button
    document.getElementById('cancelBtn').addEventListener('click', () => {
      hideModal();
      document.getElementById('importBtn').disabled = false;
      document.getElementById('importBtn').textContent = 'Enregistrer la competition';
    });

    // Show existing tournament warning modal
    function showExistingTournamentModal(tournament) {
      const modal = document.getElementById('existingTournamentModal');
      const info = document.getElementById('existingTournamentInfo');

      const importDate = tournament.importDate
        ? new Date(tournament.importDate).toLocaleDateString('fr-FR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' })
        : 'Non renseign√©e';

      info.innerHTML = `
        <p style="margin: 0 0 8px 0;"><strong>${tournament.categoryName}</strong></p>
        <p style="margin: 0 0 8px 0;">Tournoi ${tournament.tournamentNumber} - Saison ${tournament.season}</p>
        <p style="margin: 0 0 8px 0;">Joueurs enregistr√©s : <strong>${tournament.playerCount}</strong></p>
        <p style="margin: 0; font-size: 12px; color: #666;">Import√© le : ${importDate}</p>
      `;

      modal.style.display = 'flex';
    }

    // Hide existing tournament modal
    function hideExistingTournamentModal() {
      document.getElementById('existingTournamentModal').style.display = 'none';
    }

    // Confirm overwrite ‚Äî single handler that dispatches by mode
    // Uses pendingOverwriteAction (set by handleStandardSubmit or handleJourneesSubmit)
    let pendingOverwriteAction = null;
    document.getElementById('confirmOverwriteBtn').addEventListener('click', async () => {
      hideExistingTournamentModal();
      if (pendingOverwriteAction) {
        await pendingOverwriteAction();
        pendingOverwriteAction = null;
      }
    });

    // Cancel overwrite button
    document.getElementById('cancelOverwriteBtn').addEventListener('click', () => {
      hideExistingTournamentModal();
      document.getElementById('importBtn').disabled = false;
      document.getElementById('importBtn').textContent = 'Enregistrer la competition';
    });

    // Check if tournament exists
    async function checkTournamentExists(categoryId, tournamentNumber, season) {
      if (!categoryId || !tournamentNumber || !season) return { exists: false };
      try {
        const response = await fetch(
          `${API_URL}/tournaments/check-exists?categoryId=${categoryId}&tournamentNumber=${tournamentNumber}&season=${encodeURIComponent(season)}`,
          { headers: { 'Authorization': `Bearer ${token}` } }
        );
        if (response.ok) {
          return await response.json();
        }
      } catch (error) {
        console.error('Error checking tournament:', error);
      }
      return { exists: false };
    }

    // Perform the actual import
    async function performImport(formData) {
      const errorDiv = document.getElementById('errorMessage');
      const successDiv = document.getElementById('successMessage');
      const importBtn = document.getElementById('importBtn');

      // Get category ID for the link
      const categoryId = document.getElementById('categorySelect').value;

      try {
        const response = await fetch(`${API_URL}/tournaments/import`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`
          },
          body: formData
        });

        const data = await response.json();

        if (response.ok) {
          successDiv.textContent = `Import r√©ussi ! ${data.imported} r√©sultats import√©s. Les classements ont √©t√© recalcul√©s.`;
          successDiv.style.display = 'block';

          // Show results
          const resultsCard = document.getElementById('resultsCard');
          const resultsDiv = document.getElementById('importResults');

          resultsDiv.innerHTML = `
            <div class="stats-grid">
              <div class="stat-card">
                <h4>R√©sultats import√©s</h4>
                <div class="stat-value">${data.imported}</div>
              </div>
            </div>
            <p style="margin-top: 20px;">
              <a href="rankings.html?categoryId=${categoryId}" class="btn btn-small">Voir les classements mis √† jour</a>
            </p>
          `;

          if (data.errors && data.errors.length > 0) {
            resultsDiv.innerHTML += `
              <div class="error" style="margin-top: 20px;">
                <strong>Erreurs rencontr√©es :</strong>
                <ul style="margin-top: 10px;">
                  ${data.errors.slice(0, 10).map(err => `<li>${err.licence || err.record}: ${err.error}</li>`).join('')}
                </ul>
              </div>
            `;
          }

          resultsCard.style.display = 'block';

          // Reset form
          fileInput.value = '';
          fileName.style.display = 'none';
          document.getElementById('importForm').reset();

          // Ask if user wants to send results email
          if (data.tournamentId && data.imported > 0) {
            setTimeout(() => {
              showSendResultsPopup(data.tournamentId, categoryId);
            }, 500);
          }
        } else {
          errorDiv.textContent = data.error || 'Erreur lors de l\'import';
          errorDiv.style.display = 'block';
        }
      } catch (error) {
        errorDiv.textContent = 'Erreur de connexion au serveur';
        errorDiv.style.display = 'block';
      } finally {
        importBtn.disabled = false;
        importBtn.textContent = 'Enregistrer la competition';
      }
    }

    // Proceed with validation (after overwrite confirmation or if no existing tournament)
    async function proceedWithValidation() {
      const errorDiv = document.getElementById('errorMessage');
      const importBtn = document.getElementById('importBtn');

      importBtn.textContent = 'Validation en cours...';

      try {
        // Validate and check for unknown players
        const validateResponse = await fetch(`${API_URL}/tournaments/validate`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`
          },
          body: currentFormData
        });

        const validateData = await validateResponse.json();

        if (!validateResponse.ok) {
          throw new Error(validateData.error || 'Erreur lors de la validation');
        }

        if (validateData.status === 'validation_required' && validateData.unknownPlayers.length > 0) {
          // Show modal for unknown players
          importBtn.textContent = 'En attente de cr√©ation des joueurs...';
          showUnknownPlayersModal(validateData.unknownPlayers);
        } else {
          // All players exist, proceed with import
          importBtn.textContent = 'Import en cours...';
          await performImport(currentFormData);
        }

      } catch (error) {
        errorDiv.textContent = error.message || 'Erreur de connexion au serveur';
        errorDiv.style.display = 'block';
        importBtn.disabled = false;
        importBtn.textContent = 'Enregistrer la competition';
      }
    }

    // Form submission - branch based on qualification mode
    document.getElementById('importForm').addEventListener('submit', async (e) => {
      e.preventDefault();

      // Guard against double-submit
      if (isSubmitting) return;

      const errorDiv = document.getElementById('errorMessage');
      const successDiv = document.getElementById('successMessage');
      const importBtn = document.getElementById('importBtn');

      errorDiv.style.display = 'none';
      successDiv.style.display = 'none';

      const categoryId = document.getElementById('categorySelect').value;
      const tournamentNumber = document.getElementById('tournamentNumber').value;
      const tournamentDate = document.getElementById('tournamentDate').value;
      const season = document.getElementById('season').value;

      if (!categoryId || !tournamentNumber || !tournamentDate || !season) {
        errorDiv.textContent = 'Veuillez remplir tous les champs';
        errorDiv.style.display = 'block';
        return;
      }

      isSubmitting = true;
      try {
        // Branch based on qualification mode
        if (window.qualificationMode === 'journees') {
          await handleJourneesSubmit(categoryId, tournamentNumber, tournamentDate, season);
        } else {
          await handleStandardSubmit(categoryId, tournamentNumber, tournamentDate, season);
        }
      } finally {
        isSubmitting = false;
      }
    });

    // Handle standard mode submit (single file)
    async function handleStandardSubmit(categoryId, tournamentNumber, tournamentDate, season) {
      const errorDiv = document.getElementById('errorMessage');
      const importBtn = document.getElementById('importBtn');

      if (!fileInput.files[0]) {
        errorDiv.textContent = 'Veuillez s√©lectionner un fichier CSV';
        errorDiv.style.display = 'block';
        return;
      }

      const formData = new FormData();
      formData.append('file', fileInput.files[0]);
      formData.append('categoryId', categoryId);
      formData.append('tournamentNumber', tournamentNumber);
      formData.append('tournamentDate', tournamentDate);
      formData.append('season', season);

      currentFormData = formData;

      importBtn.disabled = true;
      importBtn.textContent = 'V√©rification...';

      try {
        const existsResult = await checkTournamentExists(categoryId, tournamentNumber, season);

        if (existsResult.exists) {
          pendingOverwriteAction = () => proceedWithValidation();
          showExistingTournamentModal(existsResult.tournament);
        } else {
          await proceedWithValidation();
        }
      } catch (error) {
        errorDiv.textContent = error.message || 'Erreur de connexion au serveur';
        errorDiv.style.display = 'block';
        importBtn.disabled = false;
        importBtn.textContent = 'Enregistrer la competition';
      }
    }

    // ========== JOURNEES MODE FUNCTIONS ==========

    // Qualification mode state
    window.qualificationMode = 'standard';
    let selectedFiles = [];
    let lastImportedTournamentId = null;

    // Load qualification mode from org settings
    async function loadQualificationMode() {
      try {
        const response = await fetch(`${API_URL}/settings/app-all`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
          const settings = await response.json();
          window.singlePouleThreshold = settings.single_poule_threshold || '6';
          if (settings.qualification_mode === 'journees') {
            window.qualificationMode = 'journees';
            switchToJourneesMode();
          }
        }
      } catch (error) {
        console.error('Error loading qualification mode:', error);
      }
    }

    // Phase icons for display
    const PHASE_ICONS = {
      'POULES': 'üéØ',
      'CLASSEMENTS': 'üìä',
      'Demi-finales': '‚öîÔ∏è',
      'Finale': 'üèÜ',
      'Petite finale': 'ü•â'
    };

    // Switch UI to journees mode
    function switchToJourneesMode() {
      document.getElementById('fileUpload').style.display = 'none';
      document.getElementById('fileInput').removeAttribute('required');
      document.getElementById('journeesUpload').style.display = 'block';

      document.getElementById('importCardTitle').textContent = "Enregistrer les r√©sultats d'une journ√©e qualificative";
      document.getElementById('importCardDescription').textContent =
        "S√©lectionnez la cat√©gorie, le num√©ro du tournoi et la saison, puis glissez tous les fichiers CSV export√©s depuis E2i.";

      setupMultiFileHandlers();
    }

    // Setup multi-file drag & drop handlers
    function setupMultiFileHandlers() {
      const multiUpload = document.getElementById('multiFileUpload');
      const multiInput = document.getElementById('multiFileInput');

      multiUpload.addEventListener('click', () => multiInput.click());

      multiUpload.addEventListener('dragover', (e) => {
        e.preventDefault();
        multiUpload.style.borderColor = 'var(--color-primary, #1F4788)';
        multiUpload.style.background = '#e7f3ff';
      });

      multiUpload.addEventListener('dragleave', () => {
        multiUpload.style.borderColor = '#ccc';
        multiUpload.style.background = '';
      });

      multiUpload.addEventListener('drop', (e) => {
        e.preventDefault();
        multiUpload.style.borderColor = '#ccc';
        multiUpload.style.background = '';
        if (e.dataTransfer.files.length > 0) {
          handleMultiFiles(e.dataTransfer.files);
        }
      });

      multiInput.addEventListener('change', () => {
        if (multiInput.files.length > 0) {
          selectedFiles = []; // Reset ‚Äî new selection replaces previous
          handleMultiFiles(multiInput.files);
        }
      });

      // Folder selector: filter to CSV files only
      const folderInput = document.getElementById('folderInput');
      folderInput.addEventListener('change', () => {
        const csvFiles = Array.from(folderInput.files).filter(f => f.name.toLowerCase().endsWith('.csv'));
        if (csvFiles.length > 0) {
          selectedFiles = []; // Reset ‚Äî folder replaces previous selection
          handleMultiFiles(csvFiles);
        } else {
          alert('Aucun fichier CSV trouv√© dans ce dossier.');
        }
      });
    }

    // Handle multiple file selection ‚Äî add all at once
    function handleMultiFiles(fileList) {
      for (const file of fileList) {
        if (!selectedFiles.find(f => f.name === file.name)) {
          selectedFiles.push(file);
        }
      }
      updatePhasesSummary();
    }

    // Detect phase from filename (mirrors backend)
    function detectPhaseFromFilename(filename) {
      const lower = filename.toLowerCase();

      // E2i naming convention: classement_phase_XXXXX.csv
      const match = lower.match(/classement[_ ]phase[_ ](.+?)\.csv$/i);
      if (match) {
        const raw = match[1].replace(/_/g, ' ').trim();
        // Normalize known phases
        if (raw.toLowerCase().includes('poule')) return 'POULES';
        if (raw.toLowerCase().includes('petite') && raw.toLowerCase().includes('finale')) return 'Petite finale';
        if (raw.toLowerCase().includes('demi')) return 'Demi-finales';
        if (raw.toLowerCase() === 'finale') return 'Finale';
        if (raw.toLowerCase().includes('classement')) return 'CLASSEMENTS';
        // Classification matches like "G7-8 - P5-6"
        return raw;
      }

      if (lower.includes('poule')) return 'POULES';
      if (lower.includes('petite') && lower.includes('finale')) return 'Petite finale';
      if (lower.includes('demi')) return 'Demi-finales';
      if (lower.includes('finale')) return 'Finale';
      if (lower.includes('classement')) return 'CLASSEMENTS';

      return filename.replace('.csv', '');
    }

    // Get icon for a phase
    function getPhaseIcon(phase) {
      if (PHASE_ICONS[phase]) return PHASE_ICONS[phase];
      // Classification matches (G7-8 - P5-6, etc.)
      if (/^G\d/.test(phase)) return 'üîÑ';
      return 'üìÑ';
    }

    // Get phase category for sorting: lower = displayed first
    function getPhaseSortOrder(phase) {
      const lower = phase.toLowerCase();
      if (lower.includes('poule')) return 0;
      if (lower.includes('classement')) return 1;
      if (/^g\d/i.test(phase)) return 2; // Classification matches
      if (lower.includes('demi')) return 3;
      if (lower.includes('petite')) return 4;
      if (lower === 'finale') return 5;
      return 2;
    }

    // Update phases summary display
    function updatePhasesSummary() {
      const summary = document.getElementById('phasesSummary');
      const list = document.getElementById('phasesList');

      if (selectedFiles.length === 0) {
        summary.style.display = 'none';
        return;
      }

      // Update drop zone to show file count
      const uploadZone = document.getElementById('multiFileUpload');
      uploadZone.style.borderColor = '#28a745';
      uploadZone.style.borderStyle = 'solid';

      // Sort files by phase order
      const filesWithPhases = selectedFiles.map((file, index) => ({
        file, index, phase: detectPhaseFromFilename(file.name)
      }));
      filesWithPhases.sort((a, b) => getPhaseSortOrder(a.phase) - getPhaseSortOrder(b.phase));

      summary.style.display = 'block';
      list.innerHTML = filesWithPhases.map(({ file, index, phase }) => {
        const icon = getPhaseIcon(phase);
        const isPoules = phase === 'POULES';
        const isFinale = phase === 'Finale';
        const bgColor = isPoules ? '#d4edda' : isFinale ? '#fff3cd' : '#f8f9fa';
        const borderColor = isPoules ? '#28a745' : isFinale ? '#ffc107' : 'var(--color-primary, #1F4788)';
        return `
          <div style="display: flex; align-items: center; gap: 10px; padding: 10px 14px; margin-bottom: 6px; background: ${bgColor}; border-radius: 8px; border-left: 4px solid ${borderColor};">
            <span style="font-size: 18px;">${icon}</span>
            <span style="flex: 1; font-weight: ${isPoules || isFinale ? 'bold' : 'normal'}; font-size: 14px;">${phase}</span>
            <span style="color: #999; font-size: 12px;">${file.name}</span>
            <button type="button" onclick="removeFile(${index})" style="background: none; border: none; color: #dc3545; cursor: pointer; font-size: 16px; padding: 0 4px;" title="Retirer">‚úï</button>
          </div>
        `;
      }).join('');
    }

    // Remove a file from the selection
    function removeFile(index) {
      selectedFiles.splice(index, 1);
      if (selectedFiles.length === 0) {
        const uploadZone = document.getElementById('multiFileUpload');
        uploadZone.style.borderColor = '#ccc';
        uploadZone.style.borderStyle = 'dashed';
      }
      updatePhasesSummary();
    }

    // Handle journees mode form submission ‚Äî go straight to validation (overwrite check moved to after Confirmer)
    async function handleJourneesSubmit(categoryId, tournamentNumber, tournamentDate, season) {
      const errorDiv = document.getElementById('errorMessage');
      const importBtn = document.getElementById('importBtn');

      if (selectedFiles.length === 0) {
        errorDiv.textContent = 'Veuillez ajouter au moins un fichier CSV';
        errorDiv.style.display = 'block';
        return;
      }

      const hasPoules = selectedFiles.some(f => detectPhaseFromFilename(f.name) === 'POULES');
      if (!hasPoules) {
        errorDiv.textContent = 'Le fichier POULES est obligatoire. Veuillez ajouter le fichier CSV de la phase POULES.';
        errorDiv.style.display = 'block';
        return;
      }

      importBtn.disabled = true;
      importBtn.textContent = 'V√©rification...';

      try {
        await proceedWithJourneesValidation(categoryId, tournamentNumber, tournamentDate, season);
      } catch (error) {
        errorDiv.textContent = error.message || 'Erreur de connexion au serveur';
        errorDiv.style.display = 'block';
        importBtn.disabled = false;
        importBtn.textContent = 'Enregistrer la competition';
      }
    }

    // Validate journees files (check unknown players across all files)
    async function proceedWithJourneesValidation(categoryId, tournamentNumber, tournamentDate, season) {
      const errorDiv = document.getElementById('errorMessage');
      const importBtn = document.getElementById('importBtn');

      importBtn.textContent = 'Validation en cours...';

      try {
        const valFormData = new FormData();
        selectedFiles.forEach(file => valFormData.append('files', file));
        valFormData.append('categoryId', categoryId);

        const validateResponse = await fetch(`${API_URL}/tournaments/validate-journee`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` },
          body: valFormData
        });

        const validateData = await validateResponse.json();

        if (!validateResponse.ok) {
          throw new Error(validateData.error || 'Erreur lors de la validation');
        }

        if (validateData.status === 'validation_required' && validateData.unknownPlayers && validateData.unknownPlayers.length > 0) {
          importBtn.textContent = 'En attente de cr√©ation des joueurs...';
          showUnknownPlayersModal(validateData.unknownPlayers);

          // Override create players button for journees mode
          document.getElementById('createPlayersBtn').onclick = async () => {
            const playersToCreate = unknownPlayers.map((player, index) => {
              const clubSelect = document.getElementById(`club_${index}`);
              if (!clubSelect.value) {
                throw new Error(`Veuillez s√©lectionner un club pour ${player.fullName}`);
              }
              return {
                licence: player.licence,
                firstName: player.firstName,
                lastName: player.lastName,
                club: clubSelect.value
              };
            });

            try {
              const createResponse = await fetch(`${API_URL}/tournaments/create-players`, {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${token}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({ players: playersToCreate })
              });

              if (!createResponse.ok) {
                throw new Error('Erreur lors de la cr√©ation des joueurs');
              }

              hideModal();
              // Re-validate (now with players created, will get preview data)
              await proceedWithJourneesValidation(categoryId, tournamentNumber, tournamentDate, season);
            } catch (error) {
              alert(error.message || 'Erreur lors de la cr√©ation des joueurs');
            }
          };
        } else if (validateData.status === 'preview') {
          // Validation passed ‚Äî show preview directly from response data
          showJourneesPreview(validateData, categoryId, tournamentNumber, tournamentDate, season);
        }
      } catch (error) {
        errorDiv.textContent = error.message || 'Erreur de connexion au serveur';
        errorDiv.style.display = 'block';
        importBtn.disabled = false;
        importBtn.textContent = 'Enregistrer la competition';
      }
    }

    // Store preview data for use during import
    let previewPositionsData = [];
    let previewPosPointsLookup = {};
    let previewMoyenneThresholds = null;

    // Show preview with computed positions + editable bonus columns + dynamic re-ranking
    function showJourneesPreview(data, categoryId, tournamentNumber, tournamentDate, season) {
      const importBtn = document.getElementById('importBtn');
      const previewContent = document.getElementById('previewContent');
      previewPositionsData = data.positions || [];
      previewPosPointsLookup = data.posPointsLookup || {};
      previewMoyenneThresholds = data.moyenneThresholds || null;
      const tqStageConfig = data.tqStageConfig || { average_bonus: 0, level_bonus: 0, participation_bonus: 0 };
      const scoringTiers = data.scoringTiers || { tier1: 1, tier2: 2, tier3: 3 };
      const showBonusMoyenne = tqStageConfig.average_bonus > 0;

      let phasesHtml = '';
      if (data.phases && data.phases.length > 0) {
        phasesHtml = `
          <div style="margin-bottom: 15px;">
            <strong>Phases d√©tect√©es :</strong> ${data.phases.join(', ')}
            &nbsp;‚Äî&nbsp;<strong>${data.playerCount}</strong> joueur${data.playerCount > 1 ? 's' : ''}
          </div>
        `;
      }

      // Thresholds info (only shown when B. Moy. column is active)
      let thresholdsHtml = '';
      if (showBonusMoyenne && previewMoyenneThresholds) {
        const t = previewMoyenneThresholds;
        thresholdsHtml = `
          <div style="margin-bottom: 12px; font-size: 12px; color: #555; background: #f0f4ff; padding: 8px 12px; border-radius: 6px; border-left: 3px solid var(--color-primary, #1F4788);">
            <strong>Bonus Moyenne auto :</strong>
            &lt; ${t.mini.toFixed(3)} ‚Üí 0 &nbsp;|&nbsp;
            ${t.mini.toFixed(3)}‚Äì${t.middle.toFixed(3)} ‚Üí +${scoringTiers.tier1} &nbsp;|&nbsp;
            ${t.middle.toFixed(3)}‚Äì${t.maxi.toFixed(3)} ‚Üí +${scoringTiers.tier2} &nbsp;|&nbsp;
            ‚â• ${t.maxi.toFixed(3)} ‚Üí +${scoringTiers.tier3}
          </div>
        `;
      }

      let tableHtml = '';
      if (data.positions && data.positions.length > 0) {
        const inputStyle = 'width: 44px; text-align: center; padding: 3px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;';
        const thStyle = 'padding: 5px 3px; text-align: center; font-size: 11px; white-space: nowrap;';

        tableHtml = `
          <div style="margin-bottom: 10px; display: flex; align-items: center; gap: 10px;">
            <label style="font-size: 13px; cursor: pointer;">
              <input type="checkbox" id="selectAllPlayers" checked onchange="toggleAllPlayers(this.checked)">
              Tout s√©lectionner / d√©s√©lectionner
            </label>
          </div>
          <div style="overflow-x: auto;">
            <table id="journeesPreviewTable" style="width: 100%; border-collapse: collapse; font-size: 12px;">
              <thead>
                <tr style="background: var(--color-primary, #1F4788); color: white;">
                  <th style="${thStyle} width: 28px;"></th>
                  <th style="${thStyle}">Joueur</th>
                  <th style="${thStyle}" title="Phases de participation">Phases</th>
                  <th style="${thStyle}">Points</th>
                  <th style="${thStyle}">Repr.</th>
                  <th style="${thStyle}">Moy.</th>
                  <th style="${thStyle}" title="Points de match (toutes phases)">Pts M.</th>
                  ${showBonusMoyenne ? `<th style="${thStyle}" title="Bonus moyenne (auto-calcul√©, modifiable)">B. Moy.</th>` : ''}
                  <th style="${thStyle}" title="Bonus de niveau">B. Niv.</th>
                  <th style="${thStyle}" title="Bonus nombre de joueurs">B. Jou.</th>
                  <th style="${thStyle}" title="Bonus libre">B. Lib.</th>
                  <th style="${thStyle} font-weight: bold;">Total</th>
                  <th style="${thStyle} font-weight: bold;">Pos.</th>
                  <th style="${thStyle} font-weight: bold;">Pts P.</th>
                </tr>
              </thead>
              <tbody>
                ${data.positions.map((p, i) => {
                  const autoBonus = p.computed_average_bonus || 0;
                  const matchPts = p.matchPoints || 0;
                  const total = matchPts + autoBonus;
                  return `
                  <tr data-index="${i}" data-licence="${p.licence}" data-match-points="${matchPts}" style="border-bottom: 1px solid #eee;">
                    <td style="padding: 4px; text-align: center;">
                      <input type="checkbox" class="player-check" data-index="${i}" checked onchange="recalculatePreview()">
                    </td>
                    <td style="padding: 4px; font-size: 11px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 140px;" title="${p.playerName || p.licence}">${p.playerName || p.licence}</td>
                    <td style="padding: 4px; text-align: left; color: #666; font-size: 10px; white-space: nowrap;" title="${p.playerPhases || ''}">${p.playerPhases || '‚Äî'}</td>
                    <td style="padding: 4px; text-align: center; color: #666;">${p.totalPoints || 0}</td>
                    <td style="padding: 4px; text-align: center; color: #666;">${p.totalReprises || 0}</td>
                    <td style="padding: 4px; text-align: center;">${p.moyenne ? p.moyenne.toFixed(3) : '‚Äî'}</td>
                    <td style="padding: 4px; text-align: center; font-weight: 600;">${matchPts}</td>
                    ${showBonusMoyenne ? `
                    <td style="padding: 4px; text-align: center;">
                      <input type="number" class="bonus-moyenne" data-index="${i}" value="${autoBonus}" min="0" max="99" style="${inputStyle}" oninput="recalculatePreview()">
                    </td>` : ''}
                    <td style="padding: 4px; text-align: center;">
                      <input type="number" class="bonus-niveau" data-index="${i}" value="0" min="0" max="99" style="${inputStyle}" oninput="recalculatePreview()">
                    </td>
                    <td style="padding: 4px; text-align: center;">
                      <input type="number" class="bonus-joueurs" data-index="${i}" value="0" min="0" max="99" style="${inputStyle}" oninput="recalculatePreview()">
                    </td>
                    <td style="padding: 4px; text-align: center;">
                      <input type="number" class="bonus-libre" data-index="${i}" value="0" min="0" max="99" style="${inputStyle}" oninput="recalculatePreview()">
                    </td>
                    <td class="cell-total" style="padding: 4px; text-align: center; font-weight: bold;">${total}</td>
                    <td class="cell-position" style="padding: 4px; text-align: center; font-weight: bold;">${p.position}</td>
                    <td class="cell-pos-points" style="padding: 4px; text-align: center; font-weight: bold; color: var(--color-primary, #1F4788);">${p.positionPoints || 0}</td>
                  </tr>
                `}).join('')}
              </tbody>
            </table>
          </div>
        `;
      }

      previewContent.innerHTML = phasesHtml + thresholdsHtml + tableHtml;

      // Run initial re-ranking to sort by total
      recalculatePreview();

      // Show preview card
      document.getElementById('previewCard').style.display = 'block';
      document.getElementById('previewCard').scrollIntoView({ behavior: 'smooth' });

      importBtn.textContent = 'En attente de confirmation...';
      importBtn.disabled = true;

      // Confirm button ‚Üí show allocation screen (intermediate step before import)
      document.getElementById('confirmImportBtn').onclick = () => {
        document.getElementById('previewCard').style.display = 'none';
        showAllocationScreen(categoryId, tournamentNumber, tournamentDate, season);
      };

      // Cancel button ‚Üí dismiss preview, re-enable form
      document.getElementById('cancelPreviewBtn').onclick = () => {
        document.getElementById('previewCard').style.display = 'none';
        importBtn.disabled = false;
        importBtn.textContent = 'Enregistrer la competition';
      };
    }

    // Show allocation screen ‚Äî clean read-only table with final positions and position points
    function showAllocationScreen(categoryId, tournamentNumber, tournamentDate, season) {
      const allocationContent = document.getElementById('allocationContent');
      const table = document.getElementById('journeesPreviewTable');
      if (!table) return;

      // Collect included players from preview DOM (already sorted by recalculatePreview)
      const rows = Array.from(table.querySelectorAll('tbody tr'));
      const rankedPlayers = [];

      for (const row of rows) {
        const checkbox = row.querySelector('.player-check');
        if (!checkbox || !checkbox.checked) continue;

        const position = parseInt(row.querySelector('.cell-position').textContent) || 0;
        const total = parseInt(row.querySelector('.cell-total').textContent) || 0;
        const idx = parseInt(row.dataset.index);
        const p = previewPositionsData[idx];
        const playerName = p ? (p.playerName || p.licence) : `Joueur ${idx + 1}`;

        rankedPlayers.push({ position, playerName, total, licence: p ? p.licence : '' });
      }

      // Sort by position ascending
      rankedPlayers.sort((a, b) => a.position - b.position);

      // Check if position points are configured
      const hasPositionPoints = Object.keys(previewPosPointsLookup).length > 0;
      const maxConfiguredPos = hasPositionPoints ? Math.max(...Object.keys(previewPosPointsLookup).map(Number)) : 0;
      const needsMorePositions = hasPositionPoints && rankedPlayers.length > maxConfiguredPos;

      let warningHtml = '';
      if (!hasPositionPoints) {
        warningHtml = `
          <div style="margin-bottom: 15px; padding: 12px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px; font-size: 13px;">
            Points par position non configur√©s. Allez dans Param√®tres > Bar√®me pour les d√©finir.
          </div>
        `;
      } else if (needsMorePositions) {
        warningHtml = `
          <div style="margin-bottom: 15px; padding: 12px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px; font-size: 13px;">
            Le bar√®me ne couvre que ${maxConfiguredPos} positions mais il y a ${rankedPlayers.length} joueurs. Les positions au-del√† recevront 0 point.
          </div>
        `;
      }

      // Build clean read-only table
      const tableHtml = `
        ${warningHtml}
        <div style="overflow-x: auto;">
          <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
            <thead>
              <tr style="background: var(--color-primary, #1F4788); color: white;">
                <th style="padding: 8px; text-align: center; width: 60px;">Pos.</th>
                <th style="padding: 8px; text-align: left;">Joueur</th>
                <th style="padding: 8px; text-align: center; width: 100px;">Pts Position</th>
              </tr>
            </thead>
            <tbody>
              ${rankedPlayers.map(p => {
                const posPoints = previewPosPointsLookup[p.position] || 0;
                return `
                  <tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 8px; text-align: center; font-weight: bold;">${p.position}</td>
                    <td style="padding: 8px;">${p.playerName}</td>
                    <td style="padding: 8px; text-align: center; font-weight: bold; color: var(--color-primary, #1F4788);">${posPoints}</td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>
      `;

      allocationContent.innerHTML = tableHtml;

      // Show allocation card
      document.getElementById('allocationCard').style.display = 'block';
      document.getElementById('allocationCard').scrollIntoView({ behavior: 'smooth' });

      // "Enregistrer la journ√©e" ‚Üí perform the actual import
      document.getElementById('confirmAllocationBtn').onclick = async () => {
        document.getElementById('allocationCard').style.display = 'none';
        await performJourneesImport(categoryId, tournamentNumber, tournamentDate, season);
      };

      // "Retour √† l'aper√ßu" ‚Üí re-show preview card (edits preserved in DOM)
      document.getElementById('backToPreviewBtn').onclick = () => {
        document.getElementById('allocationCard').style.display = 'none';
        document.getElementById('previewCard').style.display = 'block';
        document.getElementById('previewCard').scrollIntoView({ behavior: 'smooth' });
      };
    }

    // Dynamic re-ranking: recalculate totals, sort positions, update position points
    function recalculatePreview() {
      const table = document.getElementById('journeesPreviewTable');
      if (!table) return;

      const rows = Array.from(table.querySelectorAll('tbody tr'));
      const playerData = [];

      // Collect data from each row
      for (const row of rows) {
        const idx = row.dataset.index;
        const checkbox = row.querySelector('.player-check');
        const included = checkbox && checkbox.checked;
        const matchPoints = parseInt(row.dataset.matchPoints) || 0;
        const bMoy = parseInt(row.querySelector('.bonus-moyenne')?.value) || 0;
        const bNiv = parseInt(row.querySelector('.bonus-niveau')?.value) || 0;
        const bJou = parseInt(row.querySelector('.bonus-joueurs')?.value) || 0;
        const bLib = parseInt(row.querySelector('.bonus-libre')?.value) || 0;
        const total = matchPoints + bMoy + bNiv + bJou + bLib;

        playerData.push({ row, idx, included, matchPoints, total });

        // Update total cell
        row.querySelector('.cell-total').textContent = total;
      }

      // Sort included players by total desc, tie-break by matchPoints desc
      const includedPlayers = playerData.filter(p => p.included);
      includedPlayers.sort((a, b) => b.total - a.total || b.matchPoints - a.matchPoints);

      // Assign positions and position points
      includedPlayers.forEach((p, idx) => {
        const position = idx + 1;
        const posPoints = previewPosPointsLookup[position] || 0;
        p.row.querySelector('.cell-position').textContent = position;
        p.row.querySelector('.cell-pos-points').textContent = posPoints;
        p.row.style.opacity = '1';
      });

      // Excluded players: clear position/points, dim row
      const excludedPlayers = playerData.filter(p => !p.included);
      for (const p of excludedPlayers) {
        p.row.querySelector('.cell-position').textContent = '‚Äî';
        p.row.querySelector('.cell-pos-points').textContent = '‚Äî';
        p.row.style.opacity = '0.4';
      }

      // Re-order rows in DOM: included (sorted by position) then excluded
      const tbody = table.querySelector('tbody');
      for (const p of includedPlayers) tbody.appendChild(p.row);
      for (const p of excludedPlayers) tbody.appendChild(p.row);
    }

    // Toggle all player checkboxes
    function toggleAllPlayers(checked) {
      document.querySelectorAll('.player-check').forEach(cb => { cb.checked = checked; });
      recalculatePreview();
    }

    // Collect included licences and bonus data from the preview table
    function collectPreviewEdits() {
      const includedLicences = [];
      const editedBonuses = [];

      previewPositionsData.forEach((p, i) => {
        const checkbox = document.querySelector(`.player-check[data-index="${i}"]`);
        if (checkbox && checkbox.checked) {
          const bonusMoyenne = document.querySelector(`.bonus-moyenne[data-index="${i}"]`);
          const bonusNiveau = document.querySelector(`.bonus-niveau[data-index="${i}"]`);
          const bonusJoueurs = document.querySelector(`.bonus-joueurs[data-index="${i}"]`);
          const bonusLibre = document.querySelector(`.bonus-libre[data-index="${i}"]`);

          includedLicences.push(p.licence);
          editedBonuses.push({
            licence: p.licence,
            bonusMoyenne: bonusMoyenne ? parseInt(bonusMoyenne.value) || 0 : 0,
            bonusNiveau: bonusNiveau ? parseInt(bonusNiveau.value) || 0 : 0,
            bonusNbJoueurs: bonusJoueurs ? parseInt(bonusJoueurs.value) || 0 : 0,
            bonusLibre: bonusLibre ? parseInt(bonusLibre.value) || 0 : 0
          });
        }
      });

      return { includedLicences, editedBonuses };
    }

    // Perform the journees import ‚Äî check for existing tournament FIRST, then import
    async function performJourneesImport(categoryId, tournamentNumber, tournamentDate, season) {
      const errorDiv = document.getElementById('errorMessage');
      const importBtn = document.getElementById('importBtn');

      importBtn.textContent = 'V√©rification...';

      try {
        const { includedLicences, editedBonuses } = collectPreviewEdits();

        if (includedLicences.length === 0) {
          errorDiv.textContent = 'Aucun joueur s√©lectionn√© pour l\'import';
          errorDiv.style.display = 'block';
          importBtn.disabled = false;
          importBtn.textContent = 'Enregistrer la competition';
          return;
        }

        // Check if tournament exists BEFORE importing (moved from handleJourneesSubmit)
        const existsResult = await checkTournamentExists(categoryId, tournamentNumber, season);
        if (existsResult.exists) {
          pendingOverwriteAction = () => doJourneesImportPost(categoryId, tournamentNumber, tournamentDate, season, includedLicences, editedBonuses);
          showExistingTournamentModal(existsResult.tournament);
          return;
        }

        await doJourneesImportPost(categoryId, tournamentNumber, tournamentDate, season, includedLicences, editedBonuses);
      } catch (error) {
        errorDiv.textContent = error.message || 'Erreur de connexion au serveur';
        errorDiv.style.display = 'block';
        importBtn.disabled = false;
        importBtn.textContent = 'Enregistrer la competition';
      }
    }

    // Actual POST to import-journee endpoint
    async function doJourneesImportPost(categoryId, tournamentNumber, tournamentDate, season, includedLicences, editedBonuses) {
      const errorDiv = document.getElementById('errorMessage');
      const successDiv = document.getElementById('successMessage');
      const importBtn = document.getElementById('importBtn');

      importBtn.textContent = 'Import en cours...';

      try {
        const formData = new FormData();
        selectedFiles.forEach(file => formData.append('files', file));
        formData.append('categoryId', categoryId);
        formData.append('tournamentNumber', tournamentNumber);
        formData.append('tournamentDate', tournamentDate);
        formData.append('season', season);
        formData.append('includedLicences', JSON.stringify(includedLicences));
        formData.append('editedBonuses', JSON.stringify(editedBonuses));

        const response = await fetch(`${API_URL}/tournaments/import-journee`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` },
          body: formData
        });

        const data = await response.json();

        if (response.ok) {
          successDiv.textContent = `Import r√©ussi ! ${data.imported} r√©sultats import√©s. Les classements ont √©t√© recalcul√©s.`;
          successDiv.style.display = 'block';

          lastImportedTournamentId = data.tournamentId;

          const resultsCard = document.getElementById('resultsCard');
          const resultsDiv = document.getElementById('importResults');

          let positionsHtml = '';
          if (data.positions && data.positions.length > 0) {
            positionsHtml = `
              <h4 style="margin-top: 20px; margin-bottom: 10px;">Classement final :</h4>
              <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
                <thead>
                  <tr style="background: var(--color-primary, #1F4788); color: white;">
                    <th style="padding: 8px; text-align: center;">Pos.</th>
                    <th style="padding: 8px; text-align: left;">Joueur</th>
                    <th style="padding: 8px; text-align: center;">Pts Position</th>
                  </tr>
                </thead>
                <tbody>
                  ${data.positions.map(p => `
                    <tr style="border-bottom: 1px solid #eee;">
                      <td style="padding: 8px; text-align: center; font-weight: bold;">${p.position}</td>
                      <td style="padding: 8px;">${p.playerName || p.licence}</td>
                      <td style="padding: 8px; text-align: center;">${p.positionPoints || 0}</td>
                    </tr>
                  `).join('')}
                </tbody>
              </table>
            `;
          }

          let phasesHtml = '';
          if (data.phases && data.phases.length > 0) {
            phasesHtml = `
              <div style="margin-top: 15px;">
                <strong>Phases import√©es :</strong> ${data.phases.join(', ')}
              </div>
            `;
          }

          resultsDiv.innerHTML = `
            <div class="stats-grid">
              <div class="stat-card">
                <h4>R√©sultats import√©s</h4>
                <div class="stat-value">${data.imported}</div>
              </div>
              <div class="stat-card">
                <h4>Phases trait√©es</h4>
                <div class="stat-value">${data.phasesCount || (data.phases ? data.phases.length : 0)}</div>
              </div>
            </div>
            ${phasesHtml}
            ${positionsHtml}
            <p style="margin-top: 20px;">
              ${data.hasManualBonuses ? `
                <span style="display: block; margin-bottom: 10px; color: #856404; background: #fff3cd; padding: 10px; border-radius: 4px;">
                  Utilisez le scoring d√©taill√© pour finaliser les bonus et recalculer les classements.
                </span>
                <a href="tournament-scoring.html?id=${data.tournamentId}" class="btn btn-small" style="background: var(--color-primary, #1F4788); margin-right: 10px;">Scoring d√©taill√©</a>
              ` : ''}
              <a href="rankings.html?categoryId=${categoryId}" class="btn btn-small">Voir les classements${data.hasManualBonuses ? '' : ' mis √† jour'}</a>
            </p>
          `;

          if (data.errors && data.errors.length > 0) {
            resultsDiv.innerHTML += `
              <div class="error" style="margin-top: 20px;">
                <strong>Erreurs rencontr√©es :</strong>
                <ul style="margin-top: 10px;">
                  ${data.errors.slice(0, 10).map(err => `<li>${err.licence || err.record}: ${err.error}</li>`).join('')}
                </ul>
              </div>
            `;
          }

          resultsCard.style.display = 'block';

          // Reset files
          selectedFiles = [];
          document.getElementById('importForm').reset();
          document.getElementById('phasesSummary').style.display = 'none';
          const uploadZone = document.getElementById('multiFileUpload');
          if (uploadZone) {
            uploadZone.style.borderColor = '#ccc';
            uploadZone.style.borderStyle = 'dashed';
          }

          // Check if mixed-category bonus is enabled
          if (data.mixedCategoryBonus && data.tournamentId) {
            setTimeout(() => showCategoryBonusStep(data.tournamentId, categoryId), 500);
          } else if (data.tournamentId && data.imported > 0) {
            setTimeout(() => showSendResultsPopup(data.tournamentId, categoryId), 500);
          }
        } else {
          errorDiv.textContent = data.error || "Erreur lors de l'import";
          errorDiv.style.display = 'block';
        }
      } catch (error) {
        errorDiv.textContent = 'Erreur de connexion au serveur';
        errorDiv.style.display = 'block';
      } finally {
        importBtn.disabled = false;
        importBtn.textContent = 'Enregistrer la competition';
      }
    }

    // Show mixed-category bonus entry step
    async function showCategoryBonusStep(tournamentId, categoryId) {
      const bonusCard = document.getElementById('categoryBonusCard');
      const bonusBody = document.getElementById('categoryBonusBody');
      const bonusMsg = document.getElementById('bonusMessage');

      try {
        const response = await fetch(`${API_URL}/tournaments/${tournamentId}/category-bonus`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (!response.ok) throw new Error('Erreur chargement bonus');

        const data = await response.json();
        const players = data.players || [];

        bonusBody.innerHTML = players.map(p => `
          <tr style="border-bottom: 1px solid #eee;">
            <td style="padding: 10px;">${p.player_name || ''}</td>
            <td style="padding: 10px; text-align: center;">${p.licence || ''}</td>
            <td style="padding: 10px; text-align: center;">${p.ffb_ranking || 'NC'}</td>
            <td style="padding: 10px; text-align: center;">${p.position || '-'}</td>
            <td style="padding: 10px; text-align: center;">
              <input type="number" min="0" max="${p.match_points || 10}" value="0"
                data-licence="${p.licence}"
                style="width: 60px; padding: 4px; text-align: center; border: 1px solid #ddd; border-radius: 4px;">
            </td>
          </tr>
        `).join('');

        bonusCard.style.display = 'block';
        bonusCard.scrollIntoView({ behavior: 'smooth' });

        // Save bonus button
        document.getElementById('saveBonusBtn').onclick = async () => {
          const bonuses = [];
          bonusBody.querySelectorAll('input[data-licence]').forEach(input => {
            const bonus = parseInt(input.value) || 0;
            if (bonus > 0) {
              bonuses.push({ licence: input.dataset.licence, bonus_points: bonus });
            }
          });

          try {
            const saveResponse = await fetch(`${API_URL}/tournaments/${tournamentId}/category-bonus`, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ bonuses })
            });

            if (saveResponse.ok) {
              bonusMsg.textContent = 'Bonus enregistr√©s et classements recalcul√©s.';
              bonusMsg.style.display = 'block';
              bonusMsg.style.background = '#d4edda';
              bonusMsg.style.color = '#155724';

              setTimeout(() => {
                showSendResultsPopup(tournamentId, categoryId);
              }, 1000);
            } else {
              throw new Error('Erreur sauvegarde');
            }
          } catch (err) {
            bonusMsg.textContent = 'Erreur lors de la sauvegarde des bonus.';
            bonusMsg.style.display = 'block';
            bonusMsg.style.background = '#f8d7da';
            bonusMsg.style.color = '#721c24';
          }
        };

        // Skip bonus button
        document.getElementById('skipBonusBtn').onclick = () => {
          bonusCard.style.display = 'none';
          showSendResultsPopup(tournamentId, categoryId);
        };
      } catch (error) {
        console.error('Error loading bonus data:', error);
        showSendResultsPopup(tournamentId, categoryId);
      }
    }

    // Load tournament rounds dynamically
    async function loadTournamentRounds() {
      try {
        const response = await fetch(`${API_URL}/reference-data/tournament-rounds`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
          const rounds = await response.json();
          const select = document.getElementById('tournamentNumber');
          select.innerHTML = '<option value="">-- S√©lectionner --</option>';
          rounds.forEach(r => {
            select.innerHTML += `<option value="${r.tournament_number}">${r.display_name}</option>`;
          });
        }
      } catch (error) {
        console.error('Error loading tournament rounds:', error);
      }
    }

    // Initialize
    loadCategories();
    loadClubs();
    loadQualificationMode();
    loadTournamentRounds();

    // Set today's date as default value
    const today = new Date().toISOString().split('T')[0];
    document.getElementById('tournamentDate').value = today;

    // Auto-calculate season for today's date
    const season = calculateSeason(today);
    document.getElementById('season').value = season;

    // Logout handler
    document.getElementById('logoutBtn').addEventListener('click', (e) => {
      e.preventDefault();
      localStorage.removeItem('token');
      localStorage.removeItem('userRole');
      window.location.href = 'login.html';
    });

    // Show send results popup
    function showSendResultsPopup(tournamentId, categoryId) {
      const modal = document.getElementById('sendResultsModal');
      modal.style.display = 'flex';

      // Handle Yes button - redirect to emailing page
      document.getElementById('sendResultsYesBtn').onclick = () => {
        modal.style.display = 'none';
        // Redirect to emailing page with tournament pre-selected
        window.location.href = `emailing.html?tab=results&tournamentId=${tournamentId}`;
      };

      // Handle No button - just close
      document.getElementById('sendResultsNoBtn').onclick = () => {
        modal.style.display = 'none';
      };
    }
  </script>
  <script src="js/help-button.js?v=203"></script>
</body>
</html>
